/**
 * @property {Object} Shopify
 * @property {Object} SPR
 */
(function () {
    'use strict';

    /**
     {# @ Module Definition #}
     */
    angular.module('app',
        [
            'ngSanitize',
            'ngAnimate',
            'ngTouch',
            'ui.bootstrap',
            'ngCookies',
            'ngDialog',
            'wipImageZoom',
            'wipYoutube',
            'bc.Flickity',
            'cgNotify',
            'ngMap',
            'video-background',
            'slickCarousel'
        ])

    // Main Configuration
        .config(config)
        // Initialize
        .run(initialize)
        // Jasper Admin Import Export
        .factory('jasperAdminService', jasperAdminService)
        .directive('jsAdminImportExport', jsAdminImportExportDirective)
        // Jasper Main Service
        .factory('jasper', jasperService)
        // Jasper Css Media Service
        .factory('jasperMatchMedia', jasperMatchMediaService)
        // Main Controller
        .controller('MainController', MainController)
        // Jasper Custom Scrollbar
        .provider('jsScrollConfig', jsScrollConfigProvider)
        .directive('jsScroll', jsScrollDirective)
        // Shopify Section Helper Directive
        .directive('shopifySection', shopifySectionDirective)
        // Whislist
        .factory('wishlistService', wishlistService)
        .directive('jsWishlist', jsWishlistDirective)
        // Jasper Recently Viewed Products
        .factory('recentlyViewedProductsService', recentlyViewedProductsService)
        .directive('jsRecentlyViewedProducts', jsRecentlyViewedProductsDirective)
        // Jasper Addresses
        .directive('jsAddresses', jsAddressesDirective)
        // Jasper Number Input
        .directive('jsNumberInput', jsNumberInputDirective)
        // Money Directive
        .directive('jsMoney', jsMoneyDirective)
        // Jasper Currency
        .factory('currencyService', currencyService)
        .directive('jsCurrencySelector', jsCurrencySelectorDirective)
        // Jasper Product Directive
        .directive('jsProductSingle', jsProductSingleDirective)
        // Jasper Add to Cart Directive
        .directive('jsAddToCart', jsAddToCartDirective)
        // Jasper Collection
        .directive('jsCollection', jsCollectionDirective)
        .directive('jsCollectionBanner', jsCollectionBannerDirective)
        // Jasper Tabs
        .directive('jsTabs', jsTabsDirective)
        .directive('jsTab', jsTabDirective)
        // Jasper Bar
        .factory('jsBar', jsBarService)
        .directive('jsBarToggle', jsBarToggleDirective)
        .directive('jsBar', jsBarDirective)
        // Jasper Cart
        .factory('cartService', cartService)
        .directive('jsAjaxCart', jsAjaxCartDirective)
        // Jasper Search
        .directive('jsBasicSearch', jsBasicSearchDirective)
        .directive('jsBasicSearchButton', jsBasicSearchButtonDirective)
        .directive('jsBasicSearchForm', jsBasicSearchFormDirective)
        .directive('jsQuickSearch', jsQuickSearchDirective)
        // Jasper Revolution Slider Helpers
        .directive('jsRevolutionSliderHelper', jsRevolutionSliderHelperDirective)
        // Jasper Flickity Slider Helpers
        .directive('jsFlickitySliderHelper', jsFlickitySliderHelperDirective)
        .directive('jsFlickityCarouselFix', jsFlickityCarouselFixDirective)
        .directive('jsFlickitySimplifiedCarousel', jsFlickitySimplifiedCarouselDirective)
        .directive('jsFlickitySelect', jsFlickitySelectDirective)
        // Jasper Absolute Header Fix
        .directive('jsAbsoluteHeaderFix', jsAbsoluteHeaderFixDirective)
        // Jasper Fill Height
        .directive('jsFillHeight', jsFillHeightDirective)
        // Jasper Sticky Header
        .directive('jsStickyHeader', jsStickyHeaderDirective)
        // Jasper Aside
        .directive('jsAside', jsAsideDirective)
        .directive('jsAsideToggle', jsAsideToggleDirective)
        // Jasper Parent Expand helper for collapsable navigiation
        .directive('jsParentExpand', jsParentExpandDirective)
        // Jasper Instagram Feed
        .directive('jsInstagramFeed', jsInstagramFeedDirective)
        // Jasper Images Loaded
        .directive('jsImagesLoaded', jsImagesLoadedDirective)
        // Jasper Popup
        .directive('jsPopup', jsPopupDirective)
        // Jasper Include - Template Directives for Mega menu genaration
        .directive('jsInclude', jsIncludeDirective)
        .directive('jsTemplate', jsTemplateDirective)
        // Jasper Scroll to Directive
        .directive('jsScrollTo', jsScrollToDirective)
        // Jasper Scroll to Section
        .service('jsScrollToSection', jsScrollToSectionService)
        .directive('jsScrollToSection', jsScrollToSectionDirective)
        // Jasper Full Screen Banner Button
        .directive('jsFullscreenBannerButton', jsFullscreenBannerButtonDirective)
        // Focus If Directive
        .directive('focusIf', focusIfDirective)
        // Key Press "Enter" Directive
        .directive('ngEnter', ngEnterDirective)
        // Popper.js Popover Directive
        .directive('jsPopover', jsPopoverDirective)
        .directive('jsPopoverTrigger', jsPopoverTriggerDirective)
        .directive('jsPopoverContent', jsPopoverContentDirective)
        // setWindowMegaMenuSettings
        .directive('jsSetWindowMegaMenuSettings', jsSetWindowMegaMenuSettings)
        // Sticky element directive
        .directive('jsSticky', jsStickyDirective)
        .directive('jsFilterShowMore', jsFilterShowMoreDirective)
        .directive('jsSplashScreen', jsSplashScreenDirective);

    /**
     {# @ Bootstrap App #}
     */
    angular.element(document).ready(function () {
        angular.bootstrap(document, ['app'],
            {
                //strictDi: true
            });
    });

    /**
     {# @ Configuration #}
     */
    function config($interpolateProvider, $cookiesProvider, $locationProvider, $compileProvider)
    {
        //Disable the debug data
        // $compileProvider.debugInfoEnabled(false);
        //$compileProvider.commentDirectivesEnabled(false);
        //$compileProvider.cssClassDirectivesEnabled(false);

        // Html5 mode
        $locationProvider.html5Mode({
            enabled     : true,
            requireBase : false,
            rewriteLinks: false
        });

        // Changing the angular templating symbol for work with liquid template system
        $interpolateProvider.startSymbol('{[{').endSymbol('}]}');

        // Set default cookie path
        $cookiesProvider.defaults.path = '/';

        // Shopify Api Config
        Shopify.money_format = window.jasper.money_format;

    }

    /**
     {# @ Initialize the App #}
     */
    function initialize(recentlyViewedProductsService, currencyService, jasperMatchMedia, jasper, jasperAdminService)
    {
        // Record Recently Viewed Product
        recentlyViewedProductsService.init();

        // Currency Service
        currencyService.init();

        // Watching media step changes
        jasperMatchMedia.watchMatchMedia();

        // Init scrollReveal
        jasper.scrollReveal.init();

        // Get the scrollbar width
        jasper.getScrollbarWidth();
    }

    /**
     {# @ Jasper Admin Service #}
     */
    function jasperAdminService($rootScope, ngDialog)
    {
        var service = this;

        // If the top most window has an '/admin/' in
        // its location.href , we are in the admin panel.
        // Otherwise, do not run this function at all!
        if ( top.location.href.indexOf('/admin/') === -1 )
        {
            return service;
        }

        // Get stuff
        var importExportButton = $(top.document).find('#js-import-export-button');
        var adminCss = $(top.document.head).find('#js-admin-css');

        service = {
            importExportDialog: undefined
        }

        // Initialize
        init();

        return service;

        /**
         * Initialize
         */
        function init()
        {
            if ( !top.window.jsContentForIndex )
            {
                // Store initial contentForIndex
                top.window.jsContentForIndex = top.window.Shopify.contentForIndex;
            }

            // Attach events
            $(document).on('shopify:section:load', updateContentForIndex);
            $(document).on('shopify:section:reorder', updateContentForIndex);

            // Add current template as a data attribute
            $(top.document.body).attr('data-current-template', window.jasper.current_template);

            // Append admin.scss.css if not exists
            if ( adminCss.length === 0 )
            {
                adminCss = $('<link id="js-admin-css" href="' + window.jasper.admin_scss_css_url + '" rel="stylesheet" type="text/css" media="all" />')
                $(top.document.head).append(adminCss);
            }

            // Add import/export button if not exists
            if ( importExportButton.length === 0 )
            {
                importExportButton = $('<div id="js-import-export-button">\n    <span>Jasper</span>\n    <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24"\n         height="24" viewBox="0 0 24 24">\n        <path fill="#1a1a1a"\n              d="M4.996 3h14.012l1.728 2.993-0.006 0.003c0.171 0.295 0.27 0.638 0.27 1.003v12c0 1.105-0.895 2-2 2h-14c-1.105 0-2-0.895-2-2v-12c0-0.362 0.096-0.702 0.264-0.994l-0.003-0.002 1.734-3.004zM5.573 4l-0.577 1h14.012l-0.577-1h-12.857zM7 12l5 5 5-5h-3v-2h-4v2h-3z"></path>\n    </svg>\n</div>').hide();

                if ( $(top.document).find('.te-top-bar') )
                {
                    $(top.document).find('.te-top-bar').append(importExportButton);
                }
                else if ( $(top.document).find('.theme-editor__header-nav') )
                {
                    $(top.document).find('.theme-editor__header-nav').append(importExportButton);
                }

                bindImportExportButton();
            }
            else
            {
                bindImportExportButton();
            }

            // Modify header section block heading
            $(top.document.body).find('.theme-editor__panel[data-panel-id="header"] .theme-editor__panel-body > h3').each(function () {
                if ( $(this).html() === 'Content' )
                {
                    $(this).html('Menu Colors, Icons & Badges');
                }
            });

            $(top.document.body).find('.theme-editor__panel[data-panel-id="footer"] .theme-editor__panel-body > h3').each(function () {
                if ( $(this).html() === 'Content' )
                {
                    $(this).html('Footer Columns');
                }
            });

            $(top.document.body).find('.theme-editor__panel[data-panel-id="product-template"] .theme-editor__panel-body > h3').each(function () {
                if ( $(this).html() === 'Content' )
                {
                    $(this).html('Product Tabs');
                }
            });
        }

        /**
         * Update contentForIndex
         */
        function updateContentForIndex()
        {
            var contentForIndex = [];

            $(top.document).find('[data-content-for-index]').children('li').each(function () {
                var sectionId = $(this).attr('data-section-id');

                if ( sectionId )
                {
                    contentForIndex.push(sectionId);
                }
            });

            if ( contentForIndex.length > 0 )
            {
                top.window.jsContentForIndex = contentForIndex;
            }
        }

        // Bind import/export button
        function bindImportExportButton()
        {
            importExportButton.on('click', function () {
                if ( service.importExportDialog )
                {
                    ngDialog.close(service.importExportDialog.id);
                    service.importExportDialog = undefined;
                }
                else
                {
                    service.importExportDialog = ngDialog.open(
                        {
                            template : '<js-admin-import-export></js-admin-import-export>',
                            className: 'ngdialog-theme-default ngdialog-admin-import-export',
                            plain    : true
                        });
                }
            });

            $rootScope.$on('ngDialog.closing', function (e, $dialog) {
                if ( service.importExportDialog )
                {
                    if ( $dialog.attr('id') === service.importExportDialog.id )
                    {
                        service.importExportDialog = undefined;
                    }
                }
            });
        }
    }

    /**
     {# @ Jasper Admin Import Export #}
     */
    function jsAdminImportExportDirective()
    {
        return {
            restrict    : 'EA',
            //language=HTML
            template    : '<div ng-show="ja.loading">\n    <div class="loading-overlay flex-items-center">\n        <div class="loading-overlay flex-items-center">\n            <div class="spinner flex-middle">\n                <div class="bounce1"></div>\n                <div class="bounce2"></div>\n                <div class="bounce3"></div>\n            </div>\n        </div>\n    </div>\n</div>\n<js-tabs class="jasper-import-export-tabs">\n    <js-tab title="Demo Presets">\n        <div class="content-wrapper">\n            <div id="demo-presets" class="list-group pb-4">\n                <div class="demo-preset" ng-repeat="(key, value) in ja.presets"\n                     ng-click="ja.applyPreset(value)">\n                    <div class="demo-preview" ng-class="key"></div>\n\n                    <div class="demo-details flex-items-space-between flex-items-middle">\n                        <div class="title">{[{ key }]}</div>\n                        <div class="preset-colors">\n                            <div class="preset-color" ng-style="{\'background-color\':value.color_primary}"\n                                 title="Primary color"></div>\n                            <div class="preset-color" ng-style="{\'background-color\':value.color_secondary}"\n                                 title="Secondary color"></div>\n                            <div class="preset-color" ng-style="{\'background-color\':value.color_primary_bg}"\n                                 title="Primary background color"></div>\n                            <div class="preset-color" ng-style="{\'background-color\':value.color_secondary_bg}"\n                                 title="Secondary background color"></div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </js-tab>\n    <js-tab title="Style Presets">\n        <div class="content-wrapper">\n            <div class="list-group pb-4">\n                <button type="button" class="mb-4 pb-6 list-group-item list-group-item-action"\n                        ng-repeat="(key, value) in ja.colorPresets" ng-click="ja.applyColorPreset(value)">\n                    <div>{[{ key }]}</div>\n                    <div class="preset-colors flex-items-center">\n                        <div class="flex-grow preset-color"\n                             ng-style="{\'background-color\':value.color_primary_bg}"></div>\n                        <div class="flex-grow preset-color" ng-style="{\'background-color\':value.color_primary}"></div>\n                        <div class="flex-grow preset-color"\n                             ng-style="{\'background-color\':value.color_secondary_bg}"></div>\n                        <div class="flex-grow preset-color" ng-style="{\'background-color\':value.color_secondary}"></div>\n                    </div>\n                </button>\n            </div>\n        </div>\n    </js-tab>\n    <js-tab title="Import">\n        <div class="content-wrapper">\n            <form ng-submit="ja.submitImportSettings()">\n                <textarea class="form-control" rows="10"\n                          ng-model="ja.importData"\n                          placeholder="Paste the exported data here..."></textarea>\n                <div class="flex-items-right pt-4">\n                    <button class="btn btn-secondary" type="submit">IMPORT AND SAVE</button>\n                </div>\n            </form>\n        </div>\n    </js-tab>\n    <js-tab title="Export">\n        <div class="content-wrapper">\n            <form><textarea class="form-control" rows="10" ng-model="ja.exportSettings"></textarea></form>\n        </div>\n    </js-tab>\n</js-tabs>',
            link        : function (scope, element, attrs) {
            },
            controller  : function ($scope, $timeout, $q, jasper) {
                var vm = this;

                // Data
                vm.loading = false;

                // Methods
                vm.applyPreset = applyPreset;
                vm.applyColorPreset = applyColorPreset;
                vm.submitImportSettings = submitImportSettings;

                //////////

                init();

                function init()
                {
                    vm.exportSettings = exportSettings();

                    getPresets();
                    getColorPresets();
                }

                /**
                 * Get presets from a file
                 */
                function getPresets()
                {
                    $.ajax({
                        url     : window.jasper.settings_data_json_url,
                        dataType: 'json',
                        type    : 'get',
                        success : function (response) {
                            $scope.$evalAsync(function () {
                                vm.presets = response.presets;
                            });
                        },
                        error   : function (XMLHttpRequest, textStatus) {
                        }
                    });
                }

                /**
                 * Get color presets from a file
                 */
                function getColorPresets()
                {
                    $.ajax({
                        url     : window.jasper.settings_color_data_json_url,
                        dataType: 'json',
                        type    : 'get',
                        success : function (response) {
                            $scope.$evalAsync(function () {
                                vm.colorPresets = response.presets;
                            });
                        },
                        error   : function (XMLHttpRequest, textStatus) {
                        }
                    });
                }

                /**
                 * Apply the selected preset
                 *
                 * @param preset
                 */
                function applyPreset(preset)
                {
                    jasper.openConfirm({
                        header : 'Be careful!',
                        message: '<div class="alert alert-danger" role="alert">This will override all theme settings\n    and reload the editor. You should backup your theme settings using Export tab before applying a Preset.\n</div>',
                        submit : 'Apply',
                        cancel : 'Cancel',
                    })
                        .then(function (value) {
                                // Merge some of the user data before applying to preset
                                // in order to preserve the user's important data
                                var currentSettings = angular.fromJson(exportSettings());

                                // Sections
                                preset['sections']['popup'] = currentSettings.sections['popup'];
                                preset['sections']['mega-menu-1'] = currentSettings.sections['mega-menu-1'];
                                preset['sections']['mega-menu-2'] = currentSettings.sections['mega-menu-2'];
                                preset['sections']['mega-menu-3'] = currentSettings.sections['mega-menu-3'];
                                preset['sections']['mega-menu-4'] = currentSettings.sections['mega-menu-4'];
                                preset['sections']['mega-menu-5'] = currentSettings.sections['mega-menu-5'];
                                preset['sections']['mega-menu-6'] = currentSettings.sections['mega-menu-6'];
                                preset['sections']['mega-menu-7'] = currentSettings.sections['mega-menu-7'];
                                preset['sections']['mega-menu-8'] = currentSettings.sections['mega-menu-8'];
                                preset['sections']['mega-menu-9'] = currentSettings.sections['mega-menu-9'];
                                preset['sections']['mega-menu-10'] = currentSettings.sections['mega-menu-10'];
                                preset['sections']['product-variant-swatches'] = currentSettings.sections['product-variant-swatches'];

                                // General Settings
                                preset['google_maps_api_key'] = currentSettings['google_maps_api_key'];
                                preset['instagram_feed_access_token'] = currentSettings['instagram_feed_access_token'];
                                preset['instagram_feed_client_id'] = currentSettings['instagram_feed_client_id'];
                                preset['custom_css'] = currentSettings['custom_css'];
                                preset['custom_js'] = currentSettings['custom_js'];

                                // Import the data
                                importSettings(preset);
                            },
                            function (reason) {
                            }
                        );
                }

                /**
                 * Apply the selected color preset
                 *
                 * @param preset
                 */
                function applyColorPreset(preset)
                {
                    var currentSettings = angular.fromJson(exportSettings());
                    var newPreset = angular.merge({}, currentSettings, preset);

                    jasper.openConfirm({
                        header : 'Be careful!',
                        message: '<div class="alert alert-danger" role="alert">This will override all theme settings\n    and reload the editor. You should backup your theme settings using Export tab before applying a Preset.\n</div>',
                        submit : 'Apply',
                        cancel : 'Cancel',
                    })
                        .then(function (value) {
                                importSettings(newPreset);
                            },
                            function (reason) {
                            }
                        );
                }

                /**
                 * Export the settings
                 *
                 * @returns {*}
                 */
                function exportSettings()
                {
                    var data = $(top.document).find('#theme-editor-form').serializeArray();

                    if ( data.length <= 1 )
                    {
                        data = $(top.document).find('[component="UI.Sidebar"]').serializeArray();
                    }

                    data.push({
                        name : 'settings[content_for_index]',
                        value: "[\"" + top.window.jsContentForIndex.join("\",\"") + "\"]"
                    });

                    var settings = {};

                    for ( var i = 0; i < data.length; i++ )
                    {
                        var path = data[i]['name'].replace('settings', '').split('][').join('|').replace('[', '').replace(']', '').split('|');
                        var value = data[i].value;

                        mapToJson(path, value, settings);
                    }

                    return angular.toJson(settings);
                }

                /**
                 * Submit the -to be imported- settings
                 */
                function submitImportSettings()
                {
                    jasper.openConfirm({
                        header : 'Be careful!',
                        message: '<div class="alert alert-danger" role="alert">This will override all theme settings\n    and reload the editor. You should backup your theme settings using Export tab before importing.\n</div>',
                        submit : 'Apply',
                        cancel : 'Cancel'
                    }).then(function (value) {
                            runUpgradesAndImportSettings(angular.fromJson(vm.importData));
                        },
                        function (reason) {
                        }
                    );
                }

                /**
                 * Run upgrades and then import the settings
                 *
                 * @param data
                 */
                function runUpgradesAndImportSettings(data)
                {
                    // Run the upgrade functions before actually importing the data
                    runUpgrades(data).then(function (data) {
                        console.info('Upgrading Jasper config completed!');
                        importSettings(data);
                    });
                }

                /**
                 * Import the settings
                 *
                 * @param data
                 */
                function importSettings(data)
                {
                    // PATCH config
                    var config = {
                        method: "PATCH",
                        url   : top.Shopify.routes.theme_editor_save(top.THEME_ID).html,
                        data  : jsonToMap(data, false, 'settings')
                    };

                    // Turn on loading indicator
                    $scope.$evalAsync(function () {
                        vm.loading = true;
                    });

                    // Import the data
                    top.Shopify
                        .ajax(config)
                        .done(function (response) {
                            top.window.location.reload();
                        })
                        .fail(function (response) {
                            console.info('fail', response);
                        });
                }

                /********************************************************/
                /* THEME UPGRADE FUNCTIONS                              */
                /********************************************************/

                // Object of upgrade functions
                vm.upgradeFunctions = {
                    '107': to_107,
                    '122': to_122
                }

                /**
                 * Upgrade to 1.0.7
                 * @param data
                 */
                function to_107(data)
                {
                    console.info('Upgrading Jasper config to 1.0.7');

                    // Create a deferred object
                    var deferred = $q.defer();

                    // 1
                    // Replace 'name' with 'title' on product variant swatches
                    var blocks = data['sections']['product-variant-swatches']['blocks'];

                    angular.forEach(blocks, function (block) {
                        var blockSettings = block['settings'];

                        // Rename...
                        if ( blockSettings['name'] )
                        {
                            blockSettings['title'] = blockSettings['name'];
                            delete blockSettings['name'];
                        }
                    });

                    // Resolve the promise
                    deferred.resolve(data);

                    // Return the promise
                    return deferred.promise;
                }

                /**
                 * Upgrade 1.2.2
                 * @param data
                 */
                function to_122(data)
                {
                    console.info('Upgrading Jasper config to 1.2.2');

                    // Create a deferred object
                    var deferred = $q.defer();

                    // Get filter blocks
                    var filterBlocks = data['sections']['collection-sidebar']['blocks'];

                    // 1
                    // Replace filter types, rename tags and visibility options and select appropriate filter type
                    angular.forEach(filterBlocks, function (filterBlock) {
                        // Figure out the filter type
                        var filterType = filterBlock.type;

                        // Get block settings
                        var blockSettings = filterBlock['settings'];

                        // Do filter specific changes
                        switch ( filterType )
                        {
                            case 'category_filter':

                                // Change the block type
                                filterBlock.type = 'filter';

                                // Change the block settings
                                blockSettings['show_filter'] = blockSettings['show_category_list_by_tags'];
                                blockSettings['tags'] = blockSettings['category_list_by_tags'];
                                blockSettings['filter_style'] = 'list';

                                // Change the title if it's empty or not defined
                                if ( !blockSettings['title'] || blockSettings['title'] && blockSettings['title'] === '' )
                                {
                                    blockSettings['title'] = 'Category';
                                }

                                // Delete unnecessary settings
                                delete blockSettings['show_category_list_by_tags'];
                                delete blockSettings['category_list_by_tags'];

                                break;

                            case 'size_filter':

                                // Change the block type
                                filterBlock.type = 'filter';

                                // Change the block settings
                                blockSettings['show_filter'] = blockSettings['show_sizes_by_tags'];
                                blockSettings['tags'] = blockSettings['sizes_by_tags'];
                                blockSettings['filter_style'] = 'boxed-buttons';

                                // Change the title if it's empty or not defined
                                if ( !blockSettings['title'] || blockSettings['title'] && blockSettings['title'] === '' )
                                {
                                    blockSettings['title'] = 'Size';
                                }

                                // Delete unnecessary settings
                                delete blockSettings['show_sizes_by_tags'];
                                delete blockSettings['sizes_by_tags'];

                                break;

                            case 'color_filter':

                                // Change the block type
                                filterBlock.type = 'filter';

                                // Change the block settings
                                blockSettings['show_filter'] = blockSettings['show_colors_by_tags'];
                                blockSettings['tags'] = blockSettings['colors_by_tags'];
                                blockSettings['filter_style'] = 'color-image-list';

                                // Change the title if it's empty or not defined
                                if ( !blockSettings['title'] || blockSettings['title'] && blockSettings['title'] === '' )
                                {
                                    blockSettings['title'] = 'Color';
                                }

                                // Delete unnecessary settings
                                delete blockSettings['show_colors_by_tags'];
                                delete blockSettings['colors_by_tags'];

                                break;

                            case 'price_filter':

                                // Change the block type
                                filterBlock.type = 'filter';

                                // Change the block settings
                                blockSettings['show_filter'] = blockSettings['show_price_by_tags'];
                                blockSettings['tags'] = blockSettings['price_by_tags'];
                                blockSettings['filter_style'] = 'list';

                                // Change the title if it's empty or not defined
                                if ( !blockSettings['title'] || blockSettings['title'] && blockSettings['title'] === '' )
                                {
                                    blockSettings['title'] = 'Price';
                                }

                                // Delete unnecessary settings
                                delete blockSettings['show_price_by_tags'];
                                delete blockSettings['price_by_tags'];

                                break;

                            case 'vendor_filter':

                                // Change the block type
                                filterBlock.type = 'filter';

                                // Change the block settings
                                blockSettings['show_filter'] = blockSettings['show_vendor_by_tags'];
                                blockSettings['tags'] = blockSettings['vendor_by_tags'];
                                blockSettings['filter_style'] = 'list';

                                // Change the title if it's empty or not defined
                                if ( !blockSettings['title'] || blockSettings['title'] && blockSettings['title'] === '' )
                                {
                                    blockSettings['title'] = 'Vendor';
                                }

                                // Delete unnecessary settings
                                delete blockSettings['show_vendor_by_tags'];
                                delete blockSettings['vendor_by_tags'];

                                break;

                            default:
                                break;
                        }
                    });

                    // Resolve the promise
                    deferred.resolve(data);

                    // Return the promise
                    return deferred.promise;
                }

                /**
                 * Run upgrades
                 *
                 * @param data
                 */
                function runUpgrades(data)
                {
                    var previousUpgradeFunction,
                        themeVersion = parseInt(angular.fromJson(vm.importData).jasper_version || 106);

                    angular.forEach(vm.upgradeFunctions, function (upgradeFunction, upgradeVersion) {
                        upgradeVersion = parseInt(upgradeVersion);

                        if ( themeVersion < upgradeVersion )
                        {
                            // First task
                            if ( !previousUpgradeFunction )
                            {
                                previousUpgradeFunction = upgradeFunction(data);
                            }
                            else
                            {
                                previousUpgradeFunction = previousUpgradeFunction.then(upgradeFunction);
                            }
                        }
                    });

                    // Theme is already at the latest version, no upgrades ran
                    if ( !previousUpgradeFunction )
                    {
                        console.info('Jasper config is already up-to-date. You are good to go!');

                        // Create a deferred object
                        var deferred = $q.defer();

                        // Resolve the promise
                        deferred.resolve(data);

                        // Return the promise
                        return deferred.promise
                    }

                    return previousUpgradeFunction;
                }

                /********************************************************/
                /* HELPERS                                              */

                /********************************************************/
                function isObject(value)
                {
                    return value === Object(value)
                }

                function isArray(value)
                {
                    return Array.isArray(value)
                }

                function isFile(value)
                {
                    return value instanceof File
                }

                function jsonToMap(obj, arr, pre)
                {
                    arr = arr || [];

                    Object.keys(obj).forEach(function (prop) {
                        var key = pre ? (pre + '[' + prop + ']') : prop

                        if ( isObject(obj[prop]) && !isArray(obj[prop]) && !isFile(obj[prop]) )
                        {
                            jsonToMap(obj[prop], arr, key)
                        }
                        else if ( isArray(obj[prop]) )
                        {
                            obj[prop].forEach(function (value) {
                                var arrayKey = key + '[]';

                                if ( isObject(value) && !isFile(value) )
                                {
                                    jsonToMap(value, arr, arrayKey)
                                }
                                else
                                {
                                    arr.push({
                                        "name" : arrayKey,
                                        "value": value
                                    });
                                }
                            })
                        }
                        else
                        {
                            arr.push({
                                "name" : key,
                                "value": obj[prop]
                            });
                        }
                    });

                    return arr;
                }

                function mapToJson(path, value, obj)
                {
                    var obj = obj || {};

                    if ( path.length === 1 )
                    {
                        // Array values
                        if ( value.indexOf('[]') > -1 )
                        {
                            value = [];
                        }
                        else if ( value.indexOf('["') > -1 )
                        {
                            value = value.replace('["', '')
                                .replace('"]', '')
                                .replace(new RegExp('","', 'g'), '|')
                                .split('|');
                        }

                        obj[path[0]] = value;
                        return obj;
                    }

                    obj[path[0]] = obj[path[0]] || {};
                    obj[path[0]] = mapToJson(path.slice(1), value, obj[path[0]]);

                    return obj;
                }
            },
            controllerAs: 'ja'
        }
    }

    /**
     {# @ Jasper Service #}
     */
    function jasperService(ngDialog, $timeout, $animate, FlickityService, notify)
    {
        var service = this,
            updateTimeout = true,
            scrollReveal = false,
            scrollbarWidth = false,
            variantSwatches,
            variantSwatchOptions = [],
            productImageAsSwatchOptions = [],
            shopifyCallLimitTime = Date.now();


        if ( window.jasper.variant_swatch_options !== '' )
        {
            variantSwatchOptions = window.jasper.variant_swatch_options.toLowerCase().split('|');
        }

        if ( window.jasper.product_image_as_swatch_options !== '' )
        {
            productImageAsSwatchOptions = window.jasper.product_image_as_swatch_options.toLowerCase().split('|');
        }

        if ( window.jasper.variant_swatches !== '' )
        {
            variantSwatches = window.jasper.variant_swatches;
        }

        service = {
            openConfirm               : function (data) {
                var header = data.header || '',
                    message = data.message || '',
                    submitText = data.submit || 'Ok',
                    cancelText = data.cancel || 'Cancel';

                return ngDialog.openConfirm({
                    template : '<div class="h3 text-bold text-uppercase text-center px-4 pt-8">' + header + '</div>\n<div class="message h4">' + message + '</div>\n<div class="buttons text-center">\n    <button class="btn btn-primary text-uppercase" ng-click="confirm()"> ' + submitText + '</button>\n    <button class="btn btn-link text-uppercase" ng-click="closeThisDialog()">' + cancelText + '</button>\n</div>',
                    plain    : true,
                    className: 'ngdialog-theme-default confirm-dialog',
                    showClose: false
                })
            },
            notify                    : function (message, duration) {
                var duration = duration || 3000;
                var messageTemplate = '<div class="secondary-bg">' + message + '</div>';

                notify({
                    messageTemplate: messageTemplate,
                    duration       : duration
                });

            },
            isMobile                  : function () {
                if ( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) )
                {
                    return true;
                }
                else
                {
                    return false;
                }
            },
            debounce                  : function (callback, val) {
                val = val || 400;
                // Debounce for update
                if ( updateTimeout )
                {
                    $timeout.cancel(updateTimeout);
                }
                updateTimeout = $timeout(function () {
                    callback();
                }, val);
            },
            debounceNative            : function (func, wait, immediate) {
                var timeout;

                return function () {
                    var context = this,
                        args = arguments;

                    var later = function () {
                        timeout = null;
                        if ( !immediate )
                        {
                            func.apply(context, args);
                        }
                    };

                    var callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);

                    if ( callNow )
                    {
                        func.apply(context, args);
                    }
                };
            },
            animateNgHide             : function (value, el, response) {
                var NG_HIDE_CLASS = 'ng-hide';
                var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';

                $animate[value ? 'removeClass' : 'addClass'](el, NG_HIDE_CLASS, {
                    tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                }).then(function () {
                    if ( response )
                    {
                        response();
                    }
                });
            },
            updateFlickityCarousels   : function (ids) {
                $timeout(function () {
                    // Flickity Carousel trigger resize
                    if ( ids && ids.length > 0 )
                    {
                        for ( var i = 0; i < ids.length; i++ )
                        {
                            FlickityService.resize(ids[i]);
                        }
                    }
                    else
                    {
                        var flickityInstances = FlickityService.instances;

                        for ( var j = 0; j < flickityInstances.length; j++ )
                        {
                            FlickityService.resize(flickityInstances[j].id);
                        }
                    }

                }, 500);
            },
            scrollReveal              : {
                init: function () {
                    $timeout(function () {
                        if ( window.jasper.scroll_reveal_enable )
                        {
                            window.sr = ScrollReveal();

                            var opts = {
                                distance  : '20px',
                                duration  : window.jasper.scroll_reveal_duration,
                                mobile    : window.jasper.scroll_reveal_mobile_enable,
                                reset     : false,
                                scale     : window.jasper.scroll_reveal_starting_scale,
                                opacity   : window.jasper.scroll_reveal_starting_opacity,
                                viewFactor: 0.001,
                                viewOffset: {
                                    top   : 100,
                                    bottom: 100,
                                    right : -64,
                                    left  : -64
                                }
                            };

                            scrollReveal = new ScrollReveal(opts);

                            scrollReveal.reveal('.animate-on-scroll');

                            // Add class to <html> if ScrollReveal is supported
                            if ( scrollReveal.isSupported() )
                            {
                                document.documentElement.classList.add('sr');
                            }
                        }
                    });

                },
                sync: function () {
                    if ( window.jasper.scroll_reveal_enable && scrollReveal && scrollReveal.isSupported() )
                    {
                        $timeout(function () {
                            if ( scrollReveal.history.length === 0 )
                            {
                                scrollReveal.reveal('.animate-on-scroll');
                            }

                            scrollReveal.sync();
                        });
                    }
                }
            },
            hideAllPopovers           : function () {
                $('.js-popover.is-open, js-popover.is-open, [js-popover].is-open').each(function () {
                    // Removal function needs to be duplicated like this.
                    // Some parts, like scroll handler event, needs evalAsync
                    // while others don't like evalAsync at all!
                    $(this).removeClass('is-open');

                    var scope = angular.element(this).scope();
                    scope.$evalAsync(function () {
                        $(this).removeClass('is-open');
                    });
                });
            },
            updateSpr                 : function () {
                if ( window.SPR && window.SPR.registerCallbacks && $(".shopify-product-reviews-badge").length > 0 )
                {
                    return window.SPR.registerCallbacks(), window.SPR.initRatingHandler(), window.SPR.initDomEls(), window.SPR.loadProducts(), window.SPR.loadBadges();
                }

                if ( window.SPR && $("#shopify-product-reviews").length > 0 )
                {
                    return window.SPR.initDomEls(), window.SPR.loadProducts();
                }
            },
            getScrollbarWidth         : function () {
                if ( !scrollbarWidth )
                {
                    service.calculateScrollbarWidth();
                }
                else
                {
                    return scrollbarWidth;
                }
            },
            calculateScrollbarWidth   : function () {
                var testerWrapperEl = $('<div id="scrollbarWidthTesterElement" />');
                var bodyEl = $('body');

                testerWrapperEl.css({
                    position  : 'absolute',
                    overflow  : 'auto',
                    visibility: 'hidden',
                    left      : '-999em',
                    right     : '-999em',
                    width     : '100px',
                    height    : '100px'
                });

                bodyEl.append(testerWrapperEl);

                var testerEl = $('<div />');

                testerEl.css({
                    width : '100%',
                    height: '200px'
                })

                testerWrapperEl.append(testerEl);

                scrollbarWidth = 100 - testerEl.width();

                // Remove the element
                testerWrapperEl.remove();
            },
            isInSwatches              : function (option) {
                if ( variantSwatchOptions.indexOf(option.toLowerCase()) !== -1 )
                {
                    return true;
                }
                return false;
            },
            isInProductImageAsSwatches: function (option) {
                if ( productImageAsSwatchOptions.indexOf(option.toLowerCase()) !== -1 )
                {
                    return true;
                }
                return false;
            },
            variantImage              : function (value) {
                var val = value.toLowerCase();
                if ( variantSwatches[val] )
                {
                    return 'url(' + variantSwatches[val].image.replace('.jpg', '_64x.jpg') + ')';
                }
            },
            variantColor              : function (value) {
                var val = value.toLowerCase();
                if ( variantSwatches[val] )
                {
                    return variantSwatches[val].color;
                }
                else
                {
                    return value;
                }
            },
            shopifySafeRequest        : function (callback) {
                var currentTime = Date.now();
                var timeBetween = currentTime - shopifyCallLimitTime;
                var delay;
                console.info(timeBetween);

                if ( timeBetween < 2000 )
                {
                    delay = shopifyCallLimitTime + 2000 - currentTime;
                    $timeout(function () {
                        response();
                    }, delay);
                    shopifyCallLimitTime = Date.now() + delay;
                }
                else
                {
                    response();
                    shopifyCallLimitTime = Date.now();
                }

                function response()
                {
                    if ( callback )
                    {
                        callback();
                    }
                };
            }
        };

        return service;
    }

    /**
     {# @ Jasper Match Media Service #}
     */

    function jasperMatchMediaService($timeout, $document, $rootScope, jasper)
    {
        var service = this,
            body = angular.element($document[0].body),
            mediaStepsArr = ['xs', 'sm', 'md', 'lg', 'xl'],
            mediaSteps = {
                xl: '(min-width: 1920px)',
                lg: '(min-width: 1280px)',
                md: '(min-width: 960px)',
                sm: '(min-width: 600px)',
                xs: '(min-width: 0px)'
            },
            currentStep,
            oldStep;

        function init()
        {
            currentStep = getCurrentStep();

            matchMediaChanged();

            var resizeListener = jasper.debounceNative(function () {
                currentStep = getCurrentStep();
                $rootScope.$broadcast('jasper::windowResized', currentStep, isOrBelow, isOrAbove);
                if ( oldStep !== currentStep )
                {
                    matchMediaChanged();
                }
            }, 400);

            var scrollListener = jasper.debounceNative(function () {
                $rootScope.$broadcast('jasper::pageScrolled');
            }, 400, true);

            window.addEventListener('resize', resizeListener);
            window.addEventListener('scroll', scrollListener);
        }

        function getCurrentStep()
        {
            var breaker = false;
            var response;

            angular.forEach(mediaSteps, function (value, step) {
                if ( !breaker && window.matchMedia(value).matches )
                {
                    response = step;
                    breaker = true;
                }
            });

            return response;

        }

        function matchMediaChanged()
        {
            body.addClass('media-step-' + currentStep);
            body.removeClass('media-step-' + oldStep);

            oldStep = currentStep;

            $timeout(function () {
                $rootScope.$broadcast('jasper::matchMediaChanged', currentStep, isOrBelow, isOrAbove);
            });
        }


        function isOrAbove(step)
        {
            var stepVal = mediaStepsArr.indexOf(step),
                currentVal = mediaStepsArr.indexOf(currentStep);

            return currentVal >= stepVal;
        }

        function isOrBelow(step)
        {
            var stepVal = mediaStepsArr.indexOf(step),
                currentVal = mediaStepsArr.indexOf(currentStep);

            return currentVal <= stepVal;
        }

        service = {
            watchMatchMedia         : init,
            triggerMatchMediaChanged: matchMediaChanged,
            getCurrentStep          : getCurrentStep,
            isOrAbove               : isOrAbove,
            isOrBelow               : isOrBelow
        };

        return service;
    }

    /**
     {# @ Main Controller #}
     */
    function MainController($compile, $rootScope, $scope, $timeout, jasperMatchMedia, jasper)
    {
        var vm = this;
        vm.dismissCustomPopup = false;

        vm.goToUrl = goToUrl;
        $rootScope.goToUrl = goToUrl;

        vm.getTimestamp = getTimestamp;
        vm.megaMenuToggled = megaMenuToggled;

        function getTimestamp()
        {
            return Date.now();
        }

        function goToUrl(url)
        {
            window.location = url;
        }

        function megaMenuToggled(opened)
        {
            if ( opened )
            {
                jasper.updateFlickityCarousels();
            }
        }

        $rootScope.$on('jasper::windowResized', function () {
            jasper.hideAllPopovers();
        });

        // Shopify Theme editor section:load fix for angular recompile
        $(document).on('shopify:section:load', function (response) {
            $(response.target).replaceWith($compile(response.target)($rootScope));

            $rootScope.$broadcast('update:customScrollbars');

            jasperMatchMedia.triggerMatchMediaChanged();

            jasper.scrollReveal.sync();

            jasper.updateSpr();

            initMasonry();
        });

        $(document).on('shopify:section:unload', function (response) {
            angular.element(response.target).scope().$destroy();
        });

        // Init Mobile Detection
        initIsMobile();

        function initIsMobile()
        {
            if ( jasper.isMobile() )
            {
                $('body').addClass('is-mobile');
            }

        }

        // Init Masonry
        initMasonry();

        function initMasonry()
        {
            var $grid = $('.grid-masonry').imagesLoaded(function () {
                $grid.masonry({
                    itemSelector   : '.grid-masonry > div',
                    columnWidth    : '.grid-sizer',
                    percentPosition: true
                });

                $grid.masonry('resize');
            });
        }

        // Fill megamenus
        fillMegamenus();

        function fillMegamenus()
        {
            $timeout(function () {
                $rootScope.megamenus = window.jasper.megamenus;
            });
        }
    }

    $.fn.extend({
        animateCss: function (animationName) {
            var animationEnd = 'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend';
            $(this).addClass('animated ' + animationName).one(animationEnd, function () {
                $(this).removeClass('animated ' + animationName);
            });
        }
    });

    /**
     {# @ Jasper Scroll Config #}
     */

    function jsScrollConfigProvider()
    {
        // Default configuration
        var defaultConfiguration = {
            wheelSpeed            : 1,
            wheelPropagation      : false,
            swipePropagation      : true,
            minScrollbarLength    : null,
            maxScrollbarLength    : null,
            useBothWheelAxes      : false,
            useKeyboard           : true,
            suppressScrollX       : false,
            suppressScrollY       : false,
            scrollXMarginOffset   : 0,
            scrollYMarginOffset   : 0,
            stopPropagationOnClick: true
        };

        // Methods
        this.config = config;

        //////////

        /**
         * Extend default configuration with the given one
         *
         * @param configuration
         */
        function config(configuration)
        {
            defaultConfiguration = angular.extend({}, defaultConfiguration, configuration);
        }

        /**
         * Service
         */
        this.$get = function () {
            var service = {
                getConfig: getConfig
            };

            return service;

            /**
             * Return the config
             */
            function getConfig()
            {
                return defaultConfiguration;
            }
        };
    }

    /**
     {# @ Jasper Scroll Directive #}
     */

    function jsScrollDirective($timeout, jsScrollConfig, $rootScope, jasper)
    {
        return {
            restrict: 'AE',
            scope   : {
                'jsScrollTrigger': '='
            },
            compile : function (tElement) {
                // No necessary if browser is working on mobile
                if ( jasper.isMobile() )
                {
                    return;
                }

                // Do not replace scrollbars if 'jasper.custom_scrollbars_enable' config disabled
                if ( !window.jasper.custom_scrollbars_enable )
                {
                    return;
                }

                // Add class
                tElement.addClass('js-scroll');

                return function postLink(scope, iElement, iAttrs) {
                    var options = {};

                    // If options supplied, evaluate the given
                    // value. This is because we don't want to
                    // have an isolated scope but still be able
                    // to use scope variables.
                    // We don't want an isolated scope because
                    // we should be able to use this everywhere
                    // especially with other directives
                    if ( iAttrs.jsScroll )
                    {
                        options = scope.$eval(iAttrs.jsScroll);
                    }

                    // Extend the given config with the ones from provider
                    options = angular.extend({}, jsScrollConfig.getConfig(), options);

                    init();

                    //Initialize
                    function init()
                    {
                        // Update the scrollbar on element mouseenter
                        iElement.on('mouseenter', updateScrollbar);

                        // Watch scrollHeight and update
                        // the scrollbar if it changes
                        scope.$watch(function () {
                            return iElement.prop('scrollHeight');
                        }, function (current, old) {
                            if ( angular.isUndefined(current) || angular.equals(current, old) )
                            {
                                return;
                            }

                            updateScrollbar();
                        });

                        // Watch scrollWidth and update
                        // the scrollbar if it changes
                        scope.$watch(function () {
                            return iElement.prop('scrollWidth');
                        }, function (current, old) {
                            if ( angular.isUndefined(current) || angular.equals(current, old) )
                            {
                                return;
                            }

                            updateScrollbar();
                        });

                        $rootScope.$on('update:customScrollbars', function () {
                            updateScrollbar();
                        });

                        if ( iAttrs.jsScrollTrigger )
                        {
                            scope.$watch('jsScrollTrigger', function (newVal, oldVal) {
                                if ( angular.isUndefined(newVal) )
                                {
                                    return;
                                }

                                if ( !newVal )
                                {
                                    PerfectScrollbar.destroy(iElement[0]);
                                }
                                else
                                {
                                    // Initialize the scrollbar
                                    $timeout(function () {
                                        PerfectScrollbar.initialize(iElement[0], options);
                                    }, 0);
                                }
                            });
                        }
                        else
                        {
                            $timeout(function () {
                                PerfectScrollbar.initialize(iElement[0], options);
                            }, 0);
                        }

                        // Cleanup on destroy
                        scope.$on('$destroy', destroy);
                    }

                    /**
                     * Update the scrollbar
                     */
                    function updateScrollbar()
                    {
                        if ( !window.jasper.custom_scrollbars_enable )
                        {
                            return;
                        }
                        PerfectScrollbar.update(iElement[0]);
                    }

                    function destroy()
                    {
                        iElement.off('mouseenter');
                        PerfectScrollbar.destroy(iElement[0]);
                    }
                };
            }
        };
    }

    /**
     {# @ Shopify Section Directive #}
     */
    function shopifySectionDirective()
    {
        return {
            restrict: 'C',
            scope   : true,
            link    : function (scope, element, attrs) {
                scope.$on('$destroy', function () {
                    scope.$broadcast('shopifySectionDirective::Destroyed');
                });

            }
        }
    }

    /**
     {# @ Wishlist Service #}
     */
    function wishlistService($cookies)
    {
        var service = this;
        service = {
            // Initialize
            init        : function () {
                // If the cookie exist
                if ( $cookies.getObject('jasperWishlist') )
                {
                    service.products = $cookies.getObject('jasperWishlist')
                }
            },
            toggle      : function (handle, variantId) {
                var productId = handle + '|' + variantId;

                if ( service.exists(handle, variantId) )
                {
                    service.remove(productId);
                }
                else
                {
                    service.add(productId);
                }
            },
            exists      : function (handle, variantId) {
                var productId = handle + '|' + variantId;

                if ( service.products.indexOf(productId) > -1 )
                {
                    return true;
                }
                else
                {
                    return false;
                }
            },
            // add product
            add         : function (productId) {
                service.products.unshift(productId);
                // Update Cookie
                service.updateCookie();
            },
            // Remove handle from array
            remove      : function (productId) {
                service.products.splice(service.products.indexOf(productId), 1);
                service.updateCookie();
            },
            // Update Cookie
            updateCookie: function () {
                // Write Cookie
                $cookies.putObject('jasperWishlist', service.products);
            },

            products: []
        };

        service.init();

        return service;
    }

    /**
     {# @ Jasper Wishlist Directive #}
     */

    function jsWishlistDirective()
    {
        return {
            restrict    : 'E',
            controller  : function ($http, wishlistService, $timeout, $q, $scope, $window) {
                var vm = this;
                var productHandles = wishlistService.products;
                vm.products = [];
                vm.loading = false;
                vm.productsLoaded = false;
                vm.formatMoney = formatMoney;
                vm.resizeImage = resizeImage;

                init();

                $scope.$watch(function () {
                    return productHandles;
                }, function (newVal, oldVal) {
                    if ( productHandles !== undefined && newVal != oldVal )
                    {
                        init();
                    }
                }, true);

                function init()
                {
                    vm.products = [];

                    if ( productHandles.length === 0 )
                    {
                        vm.loading = false;
                        return;
                    }

                    vm.loading = true;

                    for ( var i = 0; i < productHandles.length; i++ )
                    {
                        getProductData(productHandles[i], function () {
                            var allLoaded = vm.products.length === productHandles.length;

                            if ( allLoaded )
                            {
                                $timeout(function () {
                                    vm.productsLoaded = true;
                                    vm.loading = false;

                                    $(window).trigger('jasper::wishlistProductsLoaded', [vm.products]);
                                });
                            }
                        });
                    }
                }

                function getProductData(handle, callback)
                {
                    var handleArr = handle.split('|');
                    var productHandle = handleArr[0];
                    var variantId = handleArr[1];

                    $http({
                        method: 'GET',
                        url   : '/products/' + productHandle + '.js'
                    }).then(function (response) {
                        var product = response.data;

                        product.selectedVariantId = variantId;
                        product.formattedPrice = formatMoney(product.price);
                        product.formattedCompareAtPrice = formatMoney(product.compare_at_price);

                        for ( var i = 0; i < product.variants.length; i++ )
                        {
                            var selectedVariant = product.variants[i];

                            if ( parseInt(selectedVariant.id) !== parseInt(variantId) )
                            {
                                continue;
                            }

                            product.selectedVariant = selectedVariant;
                            break;
                        }

                        vm.products.push(product);

                        callback();
                    }, function () {
                        wishlistService.remove(productHandle);
                    });
                }

                function formatMoney(money)
                {
                    //money = Currency.convert(money, window.jasper.shop_currency , Currency.currentCurrency);
                    return Shopify.formatMoney(money);
                }

                $timeout(function () {
                    $scope.$watch(
                        function () {
                            return $window.Shopify.money_format;
                        }, function (newVal, oldVal) {
                        }, true);
                });

                function resizeImage(img, size)
                {
                    var imgUrl = Shopify.resizeImage(img, size);
                    var customRatio = window.jasper.enable_product_custom_aspect_ratio;

                    if ( customRatio )
                    {
                        imgUrl = imgUrl.replace('.jpg', '_crop_{{ settings.product_image_crop }}.jpg');
                    }

                    return imgUrl;
                }
            },
            controllerAs: 'vm'
        }
    }


    /**
     {# @ Recently Viewed Products Service #}
     */
    function recentlyViewedProductsService($cookies)
    {
        var service = this;
        var productLimit = 10;

        service = {
            // Initialize
            init        : function () {
                // If the cookie exist
                if ( $cookies.getObject('recentlyViewedProducts') )
                {
                    service.products = $cookies.getObject('recentlyViewedProducts')
                    service.updateCookie();
                }

                // If the location is a product page, save the product handle
                if ( window.location.pathname.indexOf('/products/') !== -1 )
                {
                    var productHandle = window.location.pathname.match(/\/products\/([a-z0-9\-]+)/)[1];
                    service.record(productHandle);
                }
            },
            // Record Cookie
            record      : function (productHandle) {
                // If exist remove it to change order
                service.remove(productHandle);
                // Add
                service.products.unshift(productHandle);
                // Update Cookie
                service.updateCookie();
            },
            // Check product limit
            checkLength : function () {
                if ( service.products.length > productLimit )
                {
                    service.products.splice(productLimit - service.products.length);
                }
            },
            // Remove handle from array
            remove      : function (productHandle) {
                if ( service.products.indexOf(productHandle) > -1 )
                {
                    service.products.splice(service.products.indexOf(productHandle), 1);
                }
            },
            // Update Cookie
            updateCookie: function () {
                // Check if exceeds the product limit
                service.checkLength();

                // Write Cookie
                $cookies.putObject('recentlyViewedProducts', service.products);
            },

            products: []
        };

        return service;
    }

    /**
     {# @ Jasper Recently Viewed Products Directive #}
     */

    function jsRecentlyViewedProductsDirective()
    {
        return {
            restrict    : 'E',
            controller  : function ($http, recentlyViewedProductsService, $timeout, $q, $scope, $window) {
                var vm = this;
                var productHandles = recentlyViewedProductsService.products;
                vm.products = [];
                vm.productsLoaded = false;
                vm.formatMoney = formatMoney;
                vm.resizeImage = resizeImage;

                if ( productHandles.length < 0 )
                {
                    return;
                }

                for ( var i = 0; i < productHandles.length; i++ )
                {
                    getProductData(productHandles[i], function () {
                        var allLoaded = vm.products.length === productHandles.length;

                        if ( allLoaded )
                        {
                            vm.productsLoaded = true;
                            $timeout(function () {
                                $(window).trigger('jasper::recentlyViewedProductsLoaded', [vm.products]);
                            });
                        }
                    });
                }

                function getProductData(handle, callback)
                {
                    $http({
                        method: 'GET',
                        url   : '/products/' + handle + '?view=json'
                    }).then(function (response) {
                        var responseData, responseDataStr;

                        if ( typeof response.data == 'object' )
                        {
                            responseData = response.data;
                        }
                        else
                        {
                            responseDataStr = JSON.stringify(response.data);
                            responseDataStr = responseDataStr.replace('<!-- END template -->', '').replace('<!-- BEGIN template --><!-- product.json -->', '');
                            responseData = JSON.parse(responseDataStr);
                            if ( typeof responseData == 'string' )
                            {
                                responseData = JSON.parse(responseData);
                            }
                        }

                        var product = responseData.product;
                        product.is_new = responseData.is_new;
                        product.template_suffix = responseData.template_suffix;
                        product.url = responseData.product_url;
                        product.formattedPrice = formatMoney(product.price);
                        product.formattedCompareAtPrice = formatMoney(product.compare_at_price);
                        vm.products.push(product);
                        callback();
                    }, function () {
                        recentlyViewedProductsService.remove(handle);
                        recentlyViewedProductsService.updateCookie();
                    });
                }

                function formatMoney(money)
                {
                    //money = Currency.convert(money, window.jasper.shop_currency , Currency.currentCurrency);
                    return Shopify.formatMoney(money);
                }

                $timeout(function () {
                    $scope.$watch(
                        function () {
                            return $window.Shopify.money_format;
                        }, function (newVal, oldVal) {
                        }, true);
                });

                function resizeImage(img, size)
                {
                    var imgUrl = Shopify.resizeImage(img, size);
                    var customRatio = window.jasper.enable_product_custom_aspect_ratio;

                    if ( customRatio )
                    {
                        imgUrl = imgUrl.replace('.jpg', '_crop_{{ settings.product_image_crop }}.jpg');
                    }

                    return imgUrl;
                }
            },
            controllerAs: 'vm'
        }
    }

    /**
     {# @ Jasper Addresses Directive #}
     */
    function jsAddressesDirective()
    {
        return {
            restrict    : 'EA',
            controllerAs: 'vm',
            controller  : function (ngDialog, $scope, jasper) {

                var vm = this;
                vm.newAddressDialog = newAddressDialog;
                vm.editAddressDialog = editAddressDialog;
                vm.deleteAddressConfirm = deleteAddressConfirm;

                function editAddressDialog(id)
                {
                    ngDialog.open(
                        {
                            template  : 'edit-address-form-' + id,
                            controller: dialogController,
                            className : 'ngdialog-theme-default address-form-dialog'
                        });
                }

                function newAddressDialog()
                {
                    ngDialog.open(
                        {
                            template  : 'new-Address-form',
                            controller: dialogController,
                            className : 'ngdialog-theme-default address-form-dialog'
                        });
                }

                function dialogController($rootScope)
                {
                    "ngInject";

                    $rootScope.$on('ngDialog.opened', registerProvinceSelector);

                    function registerProvinceSelector(e, $dialog)
                    {
                        if ( angular.element(document.getElementById('AddressCountry')).length > 0 )
                        {
                            new Shopify.CountryProvinceSelector('AddressCountry', 'AddressProvince', {
                                    hideElement: 'AddressProvinceContainer'
                                }
                            );
                        }
                    }
                }

                function deleteAddressConfirm(id)
                {
                    jasper.openConfirm({
                        header : 'Delete Address',
                        message: angular.fromJson(window.jasper.customer_addresses_delete_confirm),
                        submit : 'Delete',
                        cancel : 'Cancel',
                    }).then(function (value) {
                        Shopify.postLink('/account/addresses/' + id, {'parameters': {'_method': 'delete'}});
                    }, function (reason) {
                    });
                }

            }
        }
    }

    /**
     {# @ Jasper Number Input Directive #}
     */
    function jsNumberInputDirective($timeout, jasper)
    {
        return {
            restrict: 'EA',
            scope   : {
                value   : '=?',
                disabled: '=?',
                min     : '=?',
                max     : '=?',
                limitMax: '=?',
                step    : '=?',
                change  : '&'
            },
            template: '<div class="jasper-number-input" ng-class="addclass">\n    <div class="input-group">\n        <button type="button" ng-click="minus()" class="input-group-addon btn-minus btn btn-link text-light"\n                ng-disabled="disabled">\n            <i class="icon-minus s14"></i>\n        </button>\n        <input name="{[{inputName}]}" type="number" id="{[{inputId}]}" class="form-control text-center" ng-model="value"\n               ng-blur="blurred()" ng-change="changed()"\n               ng-readonly="disabled" ng-disabled="disabled">\n        <button type="button" ng-click="plus()" class="input-group-addon btn-plus btn btn-link text-light"\n                ng-disabled="disabled">\n            <i class="icon-plus s14"></i>\n        </button>\n    </div>\n</div>',
            replace : true,
            link    : function (scope, element, attrs) {
                var setValue,
                    changeDelay,
                    inputEl = angular.element(element).find('input')[0];

                /**
                 * Set some scope wide properties
                 */
                scope.inputId = (angular.isUndefined(attrs.inputId) ? null : attrs.inputId);
                scope.inputName = (angular.isUndefined(attrs.inputName) ? null : attrs.inputName);
                scope.addclass = (angular.isUndefined(attrs.addclass) ? null : attrs.addclass);

                scope.disabled == angular.isDefined(scope.disabled) ? scope.disabled : false;
                scope.value = angular.isDefined(scope.value) ? scope.value : void 0;
                scope.min = angular.isDefined(scope.min) ? scope.min : void 0;
                scope.max = angular.isDefined(scope.max) ? scope.max : void 0;
                scope.step = angular.isDefined(scope.step) ? scope.step : 1;

                scope.minus = minus;
                scope.plus = plus;
                scope.changed = changed;
                scope.blurred = blurred;

                /**
                 * If max value changes
                 * Check value
                 */
                scope.$watch('max', function (newVal, oldVal) {
                    if ( newVal !== oldVal )
                    {
                        scope.value = setValue(scope.value);
                    }
                });

                scope.$watch('value', jasper.debounceNative(function (newVal, oldVal) {
                        if ( oldVal != undefined && newVal !== oldVal )
                        {
                            var event = {
                                target: inputEl
                            }

                            scope.change({event: event});
                        }
                    }, 300)
                );

                scope.$watch('disabled', function (newVal, oldVal) {
                    if ( oldVal != undefined && newVal !== oldVal )
                    {
                        if ( newVal )
                        {
                            scope.min = 0
                            scope.value = setValue(0);
                        }
                        else
                        {
                            scope.min = 1
                            scope.value = setValue(1);
                        }
                    }
                });

                /**
                 * Sets the value as an integer. If the value cannot be parsed,
                 * i.e. returns NaN, then the min value or 0 will be used instead.
                 */
                function setValue(val)
                {
                    var parsedVal = parseInt(val);

                    if ( !isNaN(parsedVal) )
                    {
                        if ( scope.min !== undefined && scope.min > parsedVal )
                        {
                            parsedVal = scope.min;
                            return parsedVal;
                        }
                        if ( scope.limitMax && scope.max !== undefined && scope.max !== 0 && scope.max < parsedVal )
                        {
                            parsedVal = scope.max;
                            return parsedVal;
                        }
                        return parsedVal;
                    }
                    else
                    {
                        console.log('parsedValue must parse to a number.');
                        parsedVal = scope.min || 0;
                        return parsedVal;
                    }
                };

                function focusInput()
                {
                    inputEl.focus();
                }

                /**
                 * Confirm the value attribute exists on the element
                 */
                if ( angular.isUndefined(scope.value) )
                {
                    throw 'Missing the value attribute on the counter directive.';
                }

                /**
                 * Decrement the value and make sure we stay within the limits, if defined.
                 */
                function minus()
                {
                    if ( scope.disabled )
                    {
                        return;
                    }

                    scope.value = setValue(scope.value - scope.step);

                    focusInput();
                };

                /**
                 * Increment the value and make sure we stay within the limits, if defined.
                 */
                function plus()
                {
                    if ( scope.disabled )
                    {
                        return;
                    }

                    scope.value = setValue(scope.value + scope.step);

                    focusInput();
                };

                /**
                 * This is only triggered 1 second after a field is manually edited
                 * by the user. Where we can perform some validation and make sure
                 * that they enter the correct values from within the restrictions.
                 */
                function changed()
                {
                    changeDelay = $timeout(function () {
                        scope.value = setValue(scope.value);
                        focusInput();
                    }, 1000, true);
                };

                /**
                 * This is only triggered when user leaves a manually edited field.
                 * Where we can perform some validation and make sure that they
                 * enter the correct values from within the restrictions.
                 */
                function blurred()
                {
                    scope.value = setValue(scope.value);
                };
            }
        };
    };

    /**
     {# @ Money Directive #}
     */
    function jsMoneyDirective($rootScope, $timeout)
    {
        return {
            restrict: 'C',
            link    : function (scope, element, attrs) {
                var lastCurrency = angular.copy(jasper.shop_currency);
                var priceText = element.text();

                function priceValue()
                {
                    var priceValue;

                    if ( angular.isUndefined(attrs.value) )
                    {
                        priceValue = parseInt(priceText.replace(/[^0-9]/g, ''), 10);
                    }
                    else
                    {
                        priceValue = attrs.value;

                    }
                    return priceValue;
                }

                scope.$watch(function () {
                        return attrs.value;
                    },
                    function (newVal, oldVal) {
                        if ( newVal !== oldVal )
                        {
                            updateValue();
                        }
                    });

                $timeout(function () {
                    updateValue();
                });

                $rootScope.$on('jasper:currencyChanged', function (currentCurrency) {
                    if ( lastCurrency === currentCurrency )
                    {
                        return;
                    }
                    updateValue();
                    lastCurrency = currentCurrency;
                });

                function formatValue(value)
                {
                    return Shopify.formatMoney(value);
                }

                function convertValue()
                {
                    var convertValue;
                    if ( !window.jasper.enable_multiple_shop_currencies || jasper.shop_currency === Currency.currentCurrency )
                    {
                        convertValue = priceValue();
                    }
                    else
                    {
                        convertValue = Currency.convert(priceValue(), jasper.shop_currency, Currency.currentCurrency);
                    }
                    return convertValue;
                }

                function updateValue()
                {
                    //console.info('money::update value triggered');
                    element.html(formatValue(convertValue()));
                }
            }
        }
    }

    /**
     {# @ Currency Service #}
     */
    function currencyService($rootScope, $timeout)
    {
        var service = this;
        // From http://country.io/data/
        var currencyMap = {
            "BD": "BDT",
            "BE": "EUR",
            "BF": "XOF",
            "BG": "BGN",
            "BA": "BAM",
            "BB": "BBD",
            "WF": "XPF",
            "BL": "EUR",
            "BM": "BMD",
            "BN": "BND",
            "BO": "BOB",
            "BH": "BHD",
            "BI": "BIF",
            "BJ": "XOF",
            "BT": "BTN",
            "JM": "JMD",
            "BV": "NOK",
            "BW": "BWP",
            "WS": "WST",
            "BQ": "USD",
            "BR": "BRL",
            "BS": "BSD",
            "JE": "GBP",
            "BY": "BYR",
            "BZ": "BZD",
            "RU": "RUB",
            "RW": "RWF",
            "RS": "RSD",
            "TL": "USD",
            "RE": "EUR",
            "TM": "TMT",
            "TJ": "TJS",
            "RO": "RON",
            "TK": "NZD",
            "GW": "XOF",
            "GU": "USD",
            "GT": "GTQ",
            "GS": "GBP",
            "GR": "EUR",
            "GQ": "XAF",
            "GP": "EUR",
            "JP": "JPY",
            "GY": "GYD",
            "GG": "GBP",
            "GF": "EUR",
            "GE": "GEL",
            "GD": "XCD",
            "GB": "GBP",
            "GA": "XAF",
            "SV": "USD",
            "GN": "GNF",
            "GM": "GMD",
            "GL": "DKK",
            "GI": "GIP",
            "GH": "GHS",
            "OM": "OMR",
            "TN": "TND",
            "JO": "JOD",
            "HR": "HRK",
            "HT": "HTG",
            "HU": "HUF",
            "HK": "HKD",
            "HN": "HNL",
            "HM": "AUD",
            "VE": "VEF",
            "PR": "USD",
            "PS": "ILS",
            "PW": "USD",
            "PT": "EUR",
            "SJ": "NOK",
            "PY": "PYG",
            "IQ": "IQD",
            "PA": "PAB",
            "PF": "XPF",
            "PG": "PGK",
            "PE": "PEN",
            "PK": "PKR",
            "PH": "PHP",
            "PN": "NZD",
            "PL": "PLN",
            "PM": "EUR",
            "ZM": "ZMK",
            "EH": "MAD",
            "EE": "EUR",
            "EG": "EGP",
            "ZA": "ZAR",
            "EC": "USD",
            "IT": "EUR",
            "VN": "VND",
            "SB": "SBD",
            "ET": "ETB",
            "SO": "SOS",
            "ZW": "ZWL",
            "SA": "SAR",
            "ES": "EUR",
            "ER": "ERN",
            "ME": "EUR",
            "MD": "MDL",
            "MG": "MGA",
            "MF": "EUR",
            "MA": "MAD",
            "MC": "EUR",
            "UZ": "UZS",
            "MM": "MMK",
            "ML": "XOF",
            "MO": "MOP",
            "MN": "MNT",
            "MH": "USD",
            "MK": "MKD",
            "MU": "MUR",
            "MT": "EUR",
            "MW": "MWK",
            "MV": "MVR",
            "MQ": "EUR",
            "MP": "USD",
            "MS": "XCD",
            "MR": "MRO",
            "IM": "GBP",
            "UG": "UGX",
            "TZ": "TZS",
            "MY": "MYR",
            "MX": "MXN",
            "IL": "ILS",
            "FR": "EUR",
            "IO": "USD",
            "SH": "SHP",
            "FI": "EUR",
            "FJ": "FJD",
            "FK": "FKP",
            "FM": "USD",
            "FO": "DKK",
            "NI": "NIO",
            "NL": "EUR",
            "NO": "NOK",
            "NA": "NAD",
            "VU": "VUV",
            "NC": "XPF",
            "NE": "XOF",
            "NF": "AUD",
            "NG": "NGN",
            "NZ": "NZD",
            "NP": "NPR",
            "NR": "AUD",
            "NU": "NZD",
            "CK": "NZD",
            "XK": "EUR",
            "CI": "XOF",
            "CH": "CHF",
            "CO": "COP",
            "CN": "CNY",
            "CM": "XAF",
            "CL": "CLP",
            "CC": "AUD",
            "CA": "CAD",
            "CG": "XAF",
            "CF": "XAF",
            "CD": "CDF",
            "CZ": "CZK",
            "CY": "EUR",
            "CX": "AUD",
            "CR": "CRC",
            "CW": "ANG",
            "CV": "CVE",
            "CU": "CUP",
            "SZ": "SZL",
            "SY": "SYP",
            "SX": "ANG",
            "KG": "KGS",
            "KE": "KES",
            "SS": "SSP",
            "SR": "SRD",
            "KI": "AUD",
            "KH": "KHR",
            "KN": "XCD",
            "KM": "KMF",
            "ST": "STD",
            "SK": "EUR",
            "KR": "KRW",
            "SI": "EUR",
            "KP": "KPW",
            "KW": "KWD",
            "SN": "XOF",
            "SM": "EUR",
            "SL": "SLL",
            "SC": "SCR",
            "KZ": "KZT",
            "KY": "KYD",
            "SG": "SGD",
            "SE": "SEK",
            "SD": "SDG",
            "DO": "DOP",
            "DM": "XCD",
            "DJ": "DJF",
            "DK": "DKK",
            "VG": "USD",
            "DE": "EUR",
            "YE": "YER",
            "DZ": "DZD",
            "US": "USD",
            "UY": "UYU",
            "YT": "EUR",
            "UM": "USD",
            "LB": "LBP",
            "LC": "XCD",
            "LA": "LAK",
            "TV": "AUD",
            "TW": "TWD",
            "TT": "TTD",
            "TR": "TRY",
            "LK": "LKR",
            "LI": "CHF",
            "LV": "EUR",
            "TO": "TOP",
            "LT": "LTL",
            "LU": "EUR",
            "LR": "LRD",
            "LS": "LSL",
            "TH": "THB",
            "TF": "EUR",
            "TG": "XOF",
            "TD": "XAF",
            "TC": "USD",
            "LY": "LYD",
            "VA": "EUR",
            "VC": "XCD",
            "AE": "AED",
            "AD": "EUR",
            "AG": "XCD",
            "AF": "AFN",
            "AI": "XCD",
            "VI": "USD",
            "IS": "ISK",
            "IR": "IRR",
            "AM": "AMD",
            "AL": "ALL",
            "AO": "AOA",
            "AQ": "",
            "AS": "USD",
            "AR": "ARS",
            "AU": "AUD",
            "AT": "EUR",
            "AW": "AWG",
            "IN": "INR",
            "AX": "EUR",
            "AZ": "AZN",
            "IE": "EUR",
            "ID": "IDR",
            "UA": "UAH",
            "QA": "QAR",
            "MZ": "MZN"
        };

        // Pick your format here:
        // money_format or money_with_currency_format
        Currency.format = 'money_format';

        var shopCurrency = window.jasper.shop_currency;

        /* Sometimes merchants change their shop currency, let's tell our JavaScript file */
        Currency.moneyFormats[shopCurrency].money_with_currency_format = window.jasper.money_with_currency_format;
        Currency.moneyFormats[shopCurrency].money_format = window.jasper.money_format;

        service = {
            // Initialize
            init        : function () {
                service.setUserCurrencyMap();

                var cookieCurrency = service.readCookie();

                if ( !isAdBlockEnabled() && window.jasper.enable_auto_currency_changer )
                {
                    $.ajax({
                        url     : '//freegeoip.net/json/',
                        type    : 'POST',
                        dataType: 'jsonp',
                        error   : function (response) {
                            console.warn('The auto currency changer request is failed or blocked.');
                            defaultCurrencySetter();
                        },
                        success : function (location) {
                            var locationCurrency = currencyMap[location.country_code];

                            // If its valid currency value
                            if ( locationCurrency && Currency.moneyFormats[locationCurrency] )
                            {
                                if ( window.jasper.auto_currency_behaviour == "only_in_the_list" )
                                {
                                    console.info("only_in_the_list");

                                    if ( service.userCurrencyMap[locationCurrency] )
                                    {
                                        locationCurrencySetter(locationCurrency);
                                    }
                                    else
                                    {
                                        defaultCurrencySetter();
                                    }

                                }
                                // add_to_list
                                else
                                {
                                    // Add location currency if its not in the list
                                    if ( !service.userCurrencyMap[locationCurrency] )
                                    {
                                        service.userCurrencyMap[locationCurrency] = locationCurrency;
                                    }

                                    locationCurrencySetter(locationCurrency);
                                }
                            }
                            // If its not valid currency value
                            else
                            {
                                defaultCurrencySetter();
                            }
                        }
                    });
                }
                else
                {
                    if ( window.adblockEnabled )
                    {
                        console.warn('The auto currency changer blocked by the adblocker.');
                    }
                    defaultCurrencySetter();
                }

                function locationCurrencySetter(locationCurrency)
                {
                    // If there is no cookie
                    // Set location currency
                    if ( cookieCurrency == null )
                    {
                        service.updateCurrency(locationCurrency);
                    }
                    // If cookie exist
                    // Set cookie currency
                    else
                    {
                        defaultCurrencySetter();
                    }
                }

                function defaultCurrencySetter()
                {
                    // If there's no cookie or it's the shop currency.
                    if ( cookieCurrency == null || cookieCurrency === shopCurrency )
                    {
                        service.updateCurrency(shopCurrency);
                    }
                    else
                    {
                        service.updateCurrency(cookieCurrency);
                    }
                }

            },
            // Record Cookie
            recordCookie: function (currency) {
                Currency.cookie.write(currency);
            },
            // Read Cookie
            readCookie  : function () {
                return Currency.cookie.read();
            },

            // Update Currency
            updateCurrency    : function (currency) {
                $timeout(function () {
                    Currency.currentCurrency = currency;

                    service.currentCurrency = currency;

                    Shopify.money_format = Currency.moneyFormats[currency].money_format;
                    service.recordCookie(currency);

                    $rootScope.currentCurrency = currency;
                    $rootScope.currentCurrencyName = service.userCurrencyMap[currency];

                    // If the current currency is not in the user currency list,
                    // Set change it to shop currency
                    if ( !service.userCurrencyMap[currency] )
                    {
                        service.updateCurrency(window.jasper.shop_currency);
                    }
                });
            },
            setUserCurrencyMap: function () {
                var currenciesArr = window.jasper.shop_currencies.split(',');
                var currencies = {};

                for ( var i = 0; i < currenciesArr.length; i++ )
                {
                    var currencyISO = currenciesArr[i].replace(/\s/g, '');
                    var currencyName = currenciesArr[i];

                    if ( currenciesArr[i].indexOf('|') > -1 )
                    {
                        currencyISO = currenciesArr[i].split('|')[0].replace(/\s/g, '');
                        currencyName = currenciesArr[i].split('|')[1];
                    }
                    currencies[currencyISO] = currencyName;
                }

                if ( !currencies[window.jasper.shop_currency] )
                {
                    currencies[window.jasper.shop_currency] = window.jasper.shop_currency;
                }

                service.userCurrencyMap = currencies;
            },
            userCurrencyMap   : {},
            currentCurrency   : ''
        };

        $rootScope.$watch(
            function () {
                return Currency.currentCurrency;
            }, function (newVal, oldVal) {
                if ( newVal !== undefined && newVal !== oldVal )
                {
                    $rootScope.$broadcast('jasper:currencyChanged', newVal);
                }
            }, true);

        return service;
    }

    /**
     {# @ Jasper Currency Selector Directive #}
     */
    function jsCurrencySelectorDirective(currencyService)
    {
        return {
            restrict    : 'EA',
            controllerAs: 'cp',
            controller  : function () {
                var vm = this;
                vm.changeCurrency = currencyService.updateCurrency;
                vm.currencies = currencyService.userCurrencyMap;
            }
        }
    }

    /**
     {# @ Jasper Product Single Directive #}
     */
    function jsProductSingleDirective()
    {
        return {
            restrict    : 'EA',
            controllerAs: 'ps',
            scope       : true,
            controller  : function (ngDialog, $scope, jasper, $timeout, $rootScope, cartService, wishlistService, $httpParamSerializer, $http) {
                var vm = this;
                vm.product = {};
                vm.options = [];
                vm.selected = {};
                vm.selected.options = {};
                vm.selected.quantity = 1;
                vm.selectedVariantId = '';
                vm.currentVariant = {};
                vm.productImageModel = {};
                vm.resizeImage = Shopify.resizeImage;
                vm.setProductImage = setProductImageIndex;
                vm.customer;
                vm.customer_tags;
                vm.customer_email;
                vm.variantSwatchOptions;
                vm.variantSwatches;
                vm.selectedVariantImage = '';
                vm.productSalePercentage = false;

                vm.init = initialize;
                vm.updateSelectedVariant = updateSelectedVariant;
                vm.addToCart = addToCart;
                vm.quickView = quickView;
                vm.setCurrentVariant = setCurrentVariant;
                vm.checkExist = checkExist;
                vm.toggleWishlist = toggleWishlist;
                vm.registerForWishlist = registerForWishlist;
                vm.checkInTheWishList = checkInTheWishList;
                vm.isInSwatches = jasper.isInSwatches;
                vm.isInProductImageAsSwatches = jasper.isInProductImageAsSwatches;
                vm.variantImage = jasper.variantImage;
                vm.variantColor = jasper.variantColor;
                vm.variantProductImage = variantProductImage;
                vm.lightBox = lightBox;
                vm.videoDialog = videoDialog;
                vm.slickGoTo = slickGoTo;

                vm.slickConfig = {
                    //dots        : true,
                    //autoplay    : false,
                    //initialSlide: 1,
                    infinite : true,
                    method   : {},
                    nextArrow: '<button class="flickity-prev-next-button next" type="button" aria-label="next"><svg viewBox="0 0 100 100"><path d="M 10,50 L 60,100 L 70,90 L 30,50  L 70,10 L 60,0 Z" class="arrow" transform="translate(100, 100) rotate(180) "></path></svg></button>',
                    prevArrow: '<button class="flickity-prev-next-button previous" type="button" aria-label="previous"><svg viewBox="0 0 100 100"><path d="M 10,50 L 60,100 L 70,90 L 30,50  L 70,10 L 60,0 Z" class="arrow"></path></svg></button>'
                }

                function initialize()
                {
                    // Product Options Setup
                    generateOptions();
                    initSelectedOptions();
                    updateSelectedVariant();

                    parseProductTabsDescription();

                    vm.customer = window.jasper.customer;
                    vm.customer_tags = $scope.$eval(window.jasper.customer_tags);
                    vm.customer_email = window.jasper.customer_email;
                    calculateSalePercentage();
                }

                function calculateSalePercentage()
                {
                    var salePercentage = 0;
                    for ( var i = 0; i < vm.product.variants.length; i++ )
                    {
                        var variant = vm.product.variants[i];

                        var variantSalePercentage = (variant.compare_at_price - variant.price) / variant.compare_at_price * 100;
                        if ( variantSalePercentage > salePercentage )
                        {
                            salePercentage = variantSalePercentage;
                        }
                    }
                    if ( salePercentage > 0 )
                    {
                        $scope.$evalAsync(function () {
                            vm.productSalePercentage = salePercentage;
                        });
                    }
                }

                function parseProductTabsDescription()
                {
                    var descriptionarr = vm.product.description.split('<p>[js-tabs]');
                    vm.product.description = descriptionarr[0];
                    vm.product.shortDescription = vm.product.description.substr(0, 144) + '...';
                    if ( descriptionarr[1] )
                    {
                        vm.product.tabs = descriptionarr[1]
                            .replace('<p>[/js-tabs]', '')
                            .replace(']</p>', ']')
                            .replace('<p>[', '[')
                            .replace('[', '<')
                            .replace(']', '>');
                    }
                }

                function setProductImageIndex(variantImage)
                {
                    vm.productImageModel = variantImage;
                    var index = 0;
                    var variantImageUrl = variantImage.featured_image.src.replace(/(^\w+:|^)\/\//, '').split('?')[0];

                    for ( var i = 0; i < vm.product.images.length; i++ )
                    {
                        var imageUrl = vm.product.images[i].replace(/(^\w+:|^)\/\//, '').split('?')[0];

                        if ( imageUrl == variantImageUrl )
                        {
                            index = i;
                            break;
                        }
                    }

                    vm.productImageIndex = index;
                }

                function slickGoTo()
                {
                    if ( vm.slickConfig.method.slickGoTo )
                    {
                        $timeout(function () {
                            vm.slickConfig.method.slickGoTo(vm.productImageIndex);
                        });
                    }
                }

                /**
                 * Generate Options
                 */
                function generateOptions()
                {
                    // if product options data comes from api
                    // For example, recently-viewed products
                    // Make them equal aq.
                    if ( angular.isObject(vm.product.options[0]) )
                    {
                        vm.options = angular.copy(vm.product.options);
                        vm.product.options = [];
                        angular.forEach(vm.options, function (option) {
                            vm.product.options.push(option.name);
                        });
                    }
                    // if product options data comes from liquid
                    else
                    {
                        // Product Options scaffold
                        angular.forEach(vm.product.options, function (option) {
                            vm.options.push({
                                name  : option,
                                values: []
                            });
                            vm.selected.options[option] = '';
                        })

                        // Filling the options
                        for ( var i = 0; i < vm.product.variants.length; i++ )
                        {
                            var variant = vm.product.variants[i];
                            for ( var j = 0; j < variant.options.length; j++ )
                            {
                                var value = variant.options[j];
                                if ( vm.options[j].values.indexOf(value) < 0 )
                                {
                                    vm.options[j].values.push(value);
                                }
                            }
                        }
                    }
                }

                function checkExist(optionName, value)
                {

                    for ( var i = 0; i < vm.product.variants.length; i++ )
                    {
                        var variant = vm.product.variants[i];

                        var checkSize = 0;

                        angular.forEach(vm.selected.options, function (val, name) {
                            if ( name == optionName )
                            {
                                var opIndex = vm.product.options.indexOf(optionName);
                                if ( variant.options[opIndex] == value )
                                {
                                    checkSize++
                                }
                            }
                            else
                            {
                                var opIndex = vm.product.options.indexOf(name);
                                if ( variant.options[opIndex] == val )
                                {
                                    checkSize++
                                }
                            }
                        });

                        if ( checkSize == vm.product.options.length )
                        {
                            return true;
                        }
                    }
                    return false;
                }

                /**
                 *  Set Selected Option with currentVariant
                 */
                function initSelectedOptions()
                {
                    angular.forEach(vm.options, function (option, key) {
                        vm.selected.options[option.name] = vm.currentVariant.options[key];
                    });
                }

                /**
                 * Update Selected Variant
                 */
                function updateSelectedVariant()
                {
                    var variantArr = [];
                    angular.forEach(vm.selected.options, function (value) {
                        variantArr.push(value);
                    });

                    var variantName = variantArr.join(' / ');

                    $scope.$evalAsync(function () {
                        vm.selectedVariant = vm.product.variants.getByProp(variantName, 'title');
                        if ( vm.selectedVariant )
                        {
                            vm.selectedVariant.productHandle = vm.product.handle;
                            vm.selectedVariantId = vm.selectedVariant.id.toString();
                            // If variant has featured image, set it
                            if ( vm.selectedVariant.featured_image )
                            {
                                vm.selectedVariantImage = vm.selectedVariant.featured_image.src;
                                setProductImageIndex(vm.selectedVariant);
                            }
                            else
                            {
                                vm.selectedVariantImage = '';
                            }
                        }
                    });
                }

                /**
                 * Add to cart
                 */
                function addToCart(ev, callback)
                {
                    if ( window.jasper.disable_ajax_cart )
                    {
                        return;

                    }

                    ev.preventDefault();

                    var data = {
                        id      : vm.selectedVariant.id,
                        quantity: vm.selected.quantity,
                    };

                    cartService.addToCart(data, vm.product, function () {
                        if ( callback )
                        {
                            callback();
                        }
                    });
                }

                /**
                 * Quick View
                 */
                function quickView(ev)
                {
                    ev.preventDefault();

                    var quickViewDialog = ngDialog.open({
                        template    : 'product-quick-view-dialog-template.html',
                        data        : vm,
                        controller  : [
                            "$scope", function ($scope) {
                                var vm = this;
                                vm.data = $scope.ngDialogData;
                            }
                        ],
                        controllerAs: 'ps',
                        className   : 'ngdialog-theme-default product-quick-view-dialog',
                    });


                    $rootScope.$on('ngDialog.opened', function (e, $dialog) {
                        var id = $dialog.attr('id');
                        if ( id === quickViewDialog.id )
                        {
                            $timeout(function () {
                                jasper.updateSpr();
                                $(window).trigger('jasper::quickViewLoaded', []);
                            });
                        }
                    });

                    ngDialog.closeAll();
                }

                function setCurrentVariant(id)
                {
                    if ( id )
                    {
                        vm.currentVariant = vm.product.variants.getByProp(id, 'id');
                    }
                    else
                    {
                        var firstAvailable = vm.product.variants.getByProp(true, 'available');
                        if ( firstAvailable )
                        {
                            vm.currentVariant = firstAvailable;
                        }
                        else
                        {
                            vm.currentVariant = vm.product.variants[0];
                        }
                        //findFirstAvailable
                    }
                }

                function checkInTheWishList(response)
                {
                    if ( !vm.selectedVariant )
                    {
                        return;
                    }

                    return wishlistService.exists(vm.selectedVariant.productHandle, vm.selectedVariant.id);

                    return;

                    if ( !vm.selectedVariant || !vm.customer )
                    {
                        return false;
                    }

                    var inTheWishList = false,
                        x = 0;

                    for ( var i = 0; i < vm.customer_tags.length; i++ )
                    {
                        var tag = vm.customer_tags[i],
                            tagParts = tag.split('|'),
                            tagX = tagParts[0],
                            tagVariantId = tagParts[2];

                        if ( tagVariantId === vm.selectedVariant.id.toString() )
                        {
                            x = tagX > x ? tagX : x
                        }
                    }

                    if ( x % 2 === 0 )
                    {
                        inTheWishList = false;
                    }
                    else
                    {
                        inTheWishList = true;
                    }

                    if ( response )
                    {
                        response(x, inTheWishList);
                        return;
                    }

                    return inTheWishList;
                }

                function toggleWishlist(e)
                {
                    e.preventDefault();
                    e.stopPropagation();

                    if ( checkInTheWishList() )
                    {
                        jasper.notify('{{ "wishlist.product_removed_html" | t }}', 6000);
                    }
                    else
                    {
                        jasper.notify('{{ "wishlist.product_added_html" | t }}', 6000);
                    }

                    wishlistService.toggle(vm.selectedVariant.productHandle, vm.selectedVariant.id);
                }

                function registerForWishlist(e)
                {
                    e.preventDefault();
                    e.stopPropagation();

                    $timeout(function () {
                        ngDialog.open({
                            template : '<div class="p-8">{{ "wishlist.create_account_html" | t }}</div>',
                            plain    : true,
                            className: 'ngdialog-theme-default',
                            showClose: true
                        })
                    });
                }

                function variantProductImage(value)
                {
                    var imageUrl = '';
                    for ( var i = 0; i < vm.product.variants.length; i++ )
                    {
                        var variant = vm.product.variants[i];
                        if ( variant.options.indexOf(value.toString()) > -1 && variant.featured_image !== '' && variant.featured_image !== null )
                        {
                            imageUrl = variant.featured_image.src;
                            break;
                        }
                    }

                    return 'url(' + imageUrl.replace('.jpg', '_64x.jpg') + ')';
                }

                function lightBox(imgUrl)
                {
                    ngDialog.open(
                        {
                            template  : '<div class="js-images-loaded light-box">\n    <div class="loading-overlay flex-items-center">\n        <div class="spinner flex-middle">\n            <div class="bounce1"></div>\n            <div class="bounce2"></div>\n            <div class="bounce3"></div>\n        </div>\n    </div>\n    <img ng-src="{[{imgUrl}]}">\n</div>',
                            className : 'ngdialog-theme-default img-light-box',
                            controller: [
                                '$scope', function ($scope) {
                                    $scope.imgUrl = imgUrl;
                                }
                            ],
                            plain     : true,
                        });
                }

                function videoDialog(data)
                {
                    var template = '<div class="iframe-wrapper dark-bg">' + data + '</div>';
                    ngDialog.open(
                        {
                            template  : template,
                            className : 'ngdialog-theme-default video-light-box',
                            controller: [
                                '$scope', function ($scope) {
                                }
                            ],
                            plain     : true,
                        });
                }

            },
            link        : function (scope, element, attributes, controller) {
                controller.el = element;
                controller.product = scope.$eval(attributes.jsProductSingle);
                controller.setCurrentVariant(parseInt(attributes.currentVariantId));
                if ( attributes.jsProductTemplateSuffix )
                {
                    controller.product.template_suffix = attributes.jsProductTemplateSuffix;
                }
                controller.init();

            }
        }
    }


    function jsAddToCartDirective($timeout)
    {
        return {
            restrict: 'EA',
            require : '^jsProductSingle',
            priority: 3,
            link    : function (scope, element, attrs, ctrl) {
                element.on('click', function (ev) {
                    if ( window.jasper.disable_ajax_cart )
                    {
                        return;
                    }
                    ev.preventDefault();
                    ev.stopPropagation();
                    var spinner = $('<div class="spinner flex-middle">\n    <div class="bounce1"></div>\n    <div class="bounce2"></div>\n    <div class="bounce3"></div>\n</div>');
                    element.append(spinner);
                    ctrl.addToCart(ev, function () {
                        $(spinner).fadeOut(400);
                        $timeout(function () {
                            $(spinner).remove();
                        }, 400);
                    });
                });
            }
        }
    }

    /**
     {# @ Jasper Collection Directive #}
     */
    function jsCollectionDirective()
    {
        return {
            restrict    : 'EA',
            controllerAs: 'cm',
            controller  : function ($window, $document, $scope, jasper, $timeout, $rootScope, cartService, $location, $httpParamSerializer, $http, $compile, jsBar, ngDialog) {
                var vm = this;

                vm.loading = false;
                vm.popoverIsOpen = false;

                vm.basePath = 'https://' + $location.$$host;
                vm.collection = {};
                vm.vendor = {};
                vm.queryParams = {
                    sort_by: 'manual',
                    page   : 1
                };
                vm.tags = {};

                vm.toggleCollectionView = toggleCollectionView;
                vm.currentCollectionView = '';
                vm.popoverToggled = popoverToggled;
                vm.variantImage = jasper.variantImage;
                vm.variantColor = jasper.variantColor;

                init();

                function init()
                {
                    initQueryParams();

                    if ( $('#collection-products').hasClass('grid') )
                    {
                        vm.currentCollectionView = 'grid';
                    }
                    else if ( $('#collection-products').hasClass('list') )
                    {
                        vm.currentCollectionView = 'list';
                    }
                }

                function popoverToggled(isOpened)
                {
                    if ( isOpened )
                    {
                        jasper.updateFlickityCarousels();
                    }
                }

                function initQueryParams()
                {
                    vm.queryParams = angular.extend(vm.queryParams, $location.$$search);
                }

                function toggleCollectionView(view)
                {
                    vm.currentCollectionView = view;
                    $('#collection-products').removeClass('grid list').addClass(view);
                }

                function updateLocation(path)
                {
                    $location.url(path);
                }

                function updateData()
                {
                    vm.loading = true;
                    vm.popoverIsOpen = false;

                    var tags = [];

                    angular.forEach(vm.tags, function (tag) {
                        if ( tag !== '' )
                        {
                            tags.push(tag);
                        }
                    });

                    var collectionHandle = vm.collection ? vm.collection.handle : 'all';

                    if ( vm.vendor )
                    {
                        collectionHandle = 'vendors';
                    }
                    var path = '/collections/' + collectionHandle + '/' + tags.toString().toLowerCase() + '?' + $httpParamSerializer(vm.queryParams);
                    var url = vm.basePath + path;

                    updateLocation(path);

                    $http({
                        method: 'GET',
                        url   : url
                    }).then(function successCallback(response) {
                        var data = $(response.data),
                            collectionHeaderBreadcrumb = data.find('#collection-header .breadcrumb'),
                            products = data.find('#collection-products'),
                            collectionFooter = data.find('#collection-footer');

                        $('#collection-header .breadcrumb').html($compile(collectionHeaderBreadcrumb.html())($scope));
                        $('#collection-products').html($compile(products.html())($scope));
                        $('#collection-footer').html($compile(collectionFooter.html())($scope));

                        $('#collection-sidebar').find('.filter-block').each(function () {
                            var blockId = $(this).attr('id');

                            if ( blockId )
                            {
                                if ( data.find('#' + blockId).length > 0 )
                                {
                                    $(this).html($compile(data.find('#' + blockId).html())($scope));
                                }
                                else
                                {
                                    $(this).html('');
                                }
                            }
                        });

                        vm.loading = false;

                        var collectionSidebar = jsBar.get('collection-sidebar');

                        if ( collectionSidebar )
                        {
                            collectionSidebar.closeBar();
                        }

                        var scrollTop = $('#collection-content-wrapper').offset().top;

                        $('html, body').animate({
                            scrollTop: scrollTop
                        }, 350);

                        jasper.scrollReveal.sync();

                        $timeout(function () {
                            $(window).trigger('jasper::collectionProductsUpdated', []);
                        });

                        jasper.updateSpr();

                    }, function errorCallback(response) {
                        console.log(response);
                    });

                }

                var paramsWatcherFn = function (newVal, oldVal) {
                    if ( oldVal !== newVal )
                    {
                        // Reset Page Number if it's not changed
                        if ( newVal.page == oldVal.page )
                        {
                            vm.queryParams.page = 1;
                        }

                        updateData();
                    }
                };

                var paramsWatcher = $scope.$watch('cm.queryParams', paramsWatcherFn, true);

                $scope.$watch('cm.tags', function (newVal, oldVal) {
                    if ( oldVal !== newVal )
                    {
                        // unbind paramsWatcher
                        paramsWatcher();

                        // Reset Page Number
                        vm.queryParams.page = 1;

                        // bind paramsWatcher again
                        paramsWatcher = $scope.$watch('cm.queryParams', paramsWatcherFn, true);

                        updateData();
                    }
                }, true);

                $document.on('shopify:section:load', function (response) {
                    if ( response.detail.sectionId !== 'collection-sidebar' )
                    {
                        return;
                    }

                    $('#shopify-section-collection-sidebar').find('.filter-list').each(function () {
                        $(this).html($compile($(this).html())($scope));
                    });
                });
            },
            link        : function (scope, element, attributes, controller) {
                // Current Collection Data
                controller.collection = angular.fromJson(attributes.collection);
                controller.vendor = angular.fromJson(attributes.vendor);
            }
        }
    }

    /**
     {# @ Jasper Collection Banner #}
     */
    function jsCollectionBannerDirective()
    {
        return {
            restrict: 'EA',
            link    : function (scope, element) {
                var bannerImg = element.find('img[alt="collection-banner"]');

                if ( bannerImg.length === 0 )
                {
                    return;
                }

                var bgImage = 'url(' + bannerImg.attr('src') + ')';
                element.css({'background-image': bgImage});

                bannerImg.remove();
            }
        }
    }

    /**
     {# @ Jasper Tabs #}
     */

    function jsTabsDirective($timeout, jasper)
    {
        return {
            restrict    : 'E',
            transclude  : true,
            scope       : {},
            controllerAs: 'tm',
            controller  : function ($scope, $timeout) {
                var vm = this;
                var panes = vm.panes = [];
                vm.ul;

                vm.init = init;
                vm.select = select;
                vm.addPane = addPane;
                vm.scrollLeft = scrollLeft;
                vm.scrollRight = scrollRight;
                vm.currentScrollPos = 0;
                vm.selectedPane;

                function init()
                {
                    vm.scrollWidth = vm.ul[0].scrollWidth;
                    vm.clientWidth = vm.ul[0].clientWidth;
                    //alert(vm.scrollWidth + '-----' + vm.clientWidth);
                }

                function selectNth(nth)
                {
                    if ( panes[nth] )
                    {
                        select(panes[nth]);
                    }
                }

                function select(pane)
                {
                    angular.forEach(panes, function (pane) {
                        pane.selected = false;
                    });
                    pane.selected = true;
                    vm.selectedPane = pane;
                    jasper.scrollReveal.sync();
                }

                function addPane(pane)
                {
                    if ( panes.length == 0 ) select(pane);
                    vm.panes.push(pane);
                }

                function scrollLeft()
                {
                    if ( vm.currentScrollPos == 0 )
                    {
                        return;
                    }

                    for ( var i = 0; i < vm.ul[0].children.length; i++ )
                    {

                        var child = vm.ul[0].children[i];
                        var childOffsetLeft = getOffsetLeft(child);

                        if ( vm.currentScrollPos <= childOffsetLeft + child.offsetWidth )
                        {
                            var prevTab = vm.ul[0].children[i - 1];
                            vm.currentScrollPos = getOffsetLeft(prevTab);
                            vm.ul.css({'transform': 'translateX(-' + (vm.currentScrollPos) + 'px)'});
                            break;
                        }
                    }
                    init();
                }

                function getOffsetLeft(child)
                {
                    var parent = $(vm.ul[0]);
                    var parentPos = parent.offset();
                    var childPos = $(child).offset();
                    return childPos.left - parentPos.left;
                }

                function scrollRight()
                {
                    if ( vm.currentScrollPos + vm.clientWidth >= vm.scrollWidth )
                    {
                        return;
                    }

                    for ( var i = 0; i < vm.ul[0].children.length; i++ )
                    {

                        var child = vm.ul[0].children[i];
                        var childOffsetLeft = getOffsetLeft(child);

                        if ( vm.currentScrollPos < childOffsetLeft )
                        {

                            vm.currentScrollPos = childOffsetLeft;
                            vm.ul.css({'transform': 'translateX(-' + (vm.currentScrollPos) + 'px)'});
                            break;
                        }
                    }
                    init();
                }

                angular.element(window).on('resize', function (e) {
                    $timeout(function () {
                        init();
                    }, 0);
                });
            },
            template    : '<div class="jasper-tabs">\n\n    <div class="row m-0 flex-items-middle">\n\n        <i ng-hide="tm.currentScrollPos == 0" class="col flex-nogrow px-0 icon-chevron-left left-arrow"\n           ng-click="tm.scrollLeft()"></i>\n\n        <div class="nav-tabs-wrapper col px-0" ng-swipe-left="tm.scrollRight()" ng-swipe-right="tm.scrollLeft()">\n            ' +
            '<ul class="nav nav-tabs">\n                ' +
            '<li class="nav-item" ng-repeat="pane in tm.panes" ng-class="{active:pane.selected}">\n                    ' +
            '<a class="nav-link text-uppercase" href="" ng-click="tm.select(pane)">{[{pane.title}]}</a>\n                ' +
            '</li>\n            ' +
            '</ul>\n        </div>\n\n        <i ng-hide="tm.currentScrollPos + tm.clientWidth  >= tm.scrollWidth"\n           class="col flex-nogrow px-0 icon-chevron-right right-arrow"\n           ng-click="tm.scrollRight()"></i>\n\n    </div>\n    ' +
            '<div class="tab-content py-6" ng-transclude></div>\n</div>' +
            '',
            replace     : true,
            link        : function (scope, element, attrs, ctrl) {
                ctrl.ul = element.find('ul');
                $timeout(function () {
                    ctrl.init();
                }, 0);
            },
        };
    }

    /**
     {# @ Jasper Tab #}
     */
    function jsTabDirective()
    {
        return {
            require   : '^jsTabs',
            restrict  : 'E',
            transclude: true,
            scope     : {title: '@'},
            link      : function (scope, element, attrs, tabsCtrl) {
                tabsCtrl.addPane(scope);
            },
            template  : '<div class="tab-pane" ng-class="{active: selected}" ng-transclude>' +
            '</div>',
            replace   : true
        };
    }

    /**
     {# @ Jasper Bar Service #}
     */
    function jsBarService()
    {
        var instances = {};

        var service = {
            register: function (instance, handle) {
                instances[handle] = instance;
            },
            get     : function (handle) {
                return instances[handle];
            },
            remove  : function (handle) {
                delete instances[handle];
            }
        };

        return service;
    }

    /**
     {# @ Jasper Bar Toggle #}
     */
    function jsBarToggleDirective(jsBar, $timeout)
    {
        return {
            restrict: 'EA',
            link    : function (scope, element, attrs, ctrl) {
                var id = attrs.jsBarToggle;
                var barScope = {};

                $timeout(function () {
                    barScope = jsBar.get(id);
                });

                element.on('click', function () {
                    if ( attrs.justClose )
                    {
                        barScope.closeBar();
                        return;
                    }

                    if ( attrs.justOpen )
                    {
                        barScope.openBar();
                        return;
                    }

                    barScope.toggle();
                });
            }
        }
    }

    /**
     {# @ Jasper Bar #}
     */
    function jsBarDirective()
    {
        return {
            restrict    : 'EA',
            scope       : true,
            controllerAs: 'jb',
            controller  : function ($scope, $rootScope, $document, $animate, $compile, $timeout, jsBar, jasper) {
                var body = $document.find('body').eq(0);
                var vm = this,
                    barElClasses = [],
                    defaultOpts = {
                        fixed              : null,
                        position           : 'left',
                        clickOutsideToClose: true,
                        bodyAppend         : true,
                        mediaStep          : false,
                        activeClasses      : 'secondary-bg'
                    };

                vm.barEl;
                vm.barId;
                vm.isOpened;
                vm.isActive;
                vm.backdropEl = angular.element('<div class="jasper-bar-backdrop animate-fade-in-out"></div>');

                vm.closeBar = closeBar;
                vm.openBar = openBar;
                vm.toggle = toggle;

                vm.init = init;

                function init()
                {
                    // Extend Default Options
                    vm.options = angular.extend(defaultOpts, vm.options);

                    // Watch Model
                    $scope.$watch('jbOpen', modelWatcherFunc);

                    // Register
                    vm.barId = vm.barId || Date.now();
                    jsBar.register(vm, vm.barId);
                    vm.barElParent = vm.barEl[0].parentElement;

                    vm.barSpacerId = vm.barId + '-spacer';

                    vm.barSpacerEl = angular.element('<div id="' + vm.barSpacerId + '"></div>');

                    initBarElClasses();
                }

                $rootScope.$on('jasper::matchMediaChanged', function (ev, currentStep, isOrBelow, isOrAbove) {
                    if ( vm.options.mediaStep )
                    {
                        closeBar();

                        if ( isOrBelow(vm.options.mediaStep) )
                        {
                            activate();
                            addBarSpacerEl();
                        }
                        else
                        {
                            deActivate();

                            vm.barEl.show();

                            // Update flickity carousels
                            updateBarFlickityCarousels();

                            $timeout(function () {
                                vm.barEl.removeClass('ng-hide');
                                jasper.scrollReveal.sync();
                            }, 400);

                            removeBarSpacerEl();
                        }
                    }
                    else
                    {
                        activate();
                    }
                });

                function addBarSpacerEl()
                {
                    if ( vm.options.bodyAppend && !$document[0].getElementById(vm.barSpacerId) )
                    {
                        vm.barEl.after(vm.barSpacerEl);
                    }
                }

                function removeBarSpacerEl()
                {
                    if ( vm.options.bodyAppend && $document[0].getElementById(vm.barSpacerId) )
                    {
                        vm.barSpacerEl.after(vm.barEl);
                        vm.barSpacerEl.remove();

                        // Update Carousels
                        updateBarFlickityCarousels();
                    }
                }

                function activate()
                {
                    if ( vm.isActive )
                    {
                        return;
                    }
                    // Add bar element classes
                    addClasses();

                    vm.isActive = true;
                }

                function deActivate()
                {
                    if ( !vm.isActive )
                    {
                        return;
                    }
                    // Remove bar element classes
                    removeClasses();

                    vm.isActive = false;
                }

                function modelWatcherFunc(newVal, oldVal)
                {
                    if ( angular.isUndefined(newVal) || angular.equals(newVal, oldVal) )
                    {
                        return;
                    }

                    if ( newVal === true )
                    {
                        toggleBar(true);
                    }
                    else
                    {
                        toggleBar(false);

                    }
                }

                function initBarElClasses()
                {
                    barElClasses = [];

                    angular.forEach(vm.options.activeClasses.split(' '), function (activeClass) {
                        barElClasses.push(activeClass);
                    });
                    barElClasses.push('secondary-bg');
                    barElClasses.push('position-' + vm.options.position);
                    barElClasses.push('animate-slide-from-' + vm.options.position);
                    barElClasses.push('jasper-bar');
                    barElClasses.push('ready');

                    if ( !$scope.jbOpen )
                    {
                        barElClasses.push('ng-hide');
                    }

                    if ( vm.options.fixed )
                    {
                        barElClasses.push('fixed-position');
                    }
                }

                function addClasses()
                {
                    angular.forEach(barElClasses, function (val) {
                        vm.barEl.addClass(val);
                    });
                }

                function removeClasses()
                {
                    angular.forEach(barElClasses, function (val) {
                        vm.barEl.removeClass(val);
                    });
                }

                function toggle()
                {
                    if ( $scope.jbOpen )
                    {
                        closeBar();
                    }
                    else
                    {
                        openBar();
                    }
                }

                function toggleBar(value)
                {
                    $scope.$evalAsync(function () {
                        // Open
                        if ( value )
                        {
                            if ( vm.options.bodyAppend )
                            {
                                $animate.enter(vm.backdropEl, angular.element(body));
                                $animate.enter(vm.barEl, angular.element(body));

                                // Update Carousels
                                updateBarFlickityCarousels();
                            }
                            else
                            {
                                $animate.enter(vm.backdropEl, vm.barElParent);
                            }
                        }
                        // Close
                        else
                        {
                            $animate.leave(vm.backdropEl);
                        }

                        jasper.animateNgHide(value, vm.barEl, function () {
                            // Open
                            if ( value )
                            {
                                angular.element($document[0].documentElement).addClass('jasper-bar-opened');
                                angular.element(body).css({
                                    marginRight: jasper.getScrollbarWidth()
                                });

                                if ( vm.options.clickOutsideToClose )
                                {
                                    $document.on('click', outSideClick);
                                }

                                vm.backdropEl.on('click', closeBar);

                                $document.on('keydown', escapeToClose);

                                autoFocus();
                            }
                            // Close
                            else
                            {
                                angular.element($document[0].documentElement).removeClass('jasper-bar-opened');
                                angular.element(body).css({
                                    marginRight: ''
                                });

                                if ( vm.options.clickOutsideToClose )
                                {
                                    $scope.$evalAsync(function () {
                                        $document.off('click', outSideClick);
                                    });
                                }

                                vm.backdropEl.off('click', closeBar);

                                $document.off('keydown', escapeToClose);
                            }
                        });
                    });
                }

                function openBar()
                {
                    $scope.$evalAsync(function () {
                        $scope.jbOpen = true;
                    });
                }

                function closeBar()
                {
                    $scope.$evalAsync(function () {
                        $scope.jbOpen = false;
                    });
                }

                /**
                 * Click Outside Event Handler
                 * @param event
                 */

                function outSideClick(event)
                {
                    var isChild = vm.barEl.has(event.target).length > 0;
                    var isSelf = vm.barEl[0] === event.target;

                    var isInside = isChild || isSelf;
                    if ( !isInside )
                    {
                        closeBar();
                    }
                }

                function autoFocus()
                {
                    if ( vm.barEl.find('.auto-focus') )
                    {
                        vm.barEl.find('.auto-focus').focus();
                    }
                }

                function escapeToClose(ev)
                {
                    if ( $scope.jbOpen && ev.keyCode === 27 )
                    {
                        closeBar();
                    }
                }

                function updateBarFlickityCarousels()
                {
                    var flickityIds = [];

                    // Get ids of flickity carousels stays inside the bar
                    vm.barEl.find('[bc-flickity]').each(function () {
                        flickityIds.push($(this).attr('bc-flickity-id'));
                    });

                    // Update flickity carousels
                    jasper.updateFlickityCarousels(flickityIds);
                }

                $scope.$on('$destroy', function () {
                    jsBar.remove(vm.barId);
                    vm.barEl.remove();
                    vm.backdropEl.remove();
                });

            },
            link        : function (scope, element, attrs, ctrl) {
                ctrl.options = angular.fromJson(attrs.options || '{}');
                ctrl.barEl = element;
                ctrl.barId = attrs.id;
                ctrl.init();
                scope.jbOpen = scope.jbOpen || false;
            }
        }
    }

    /**
     {# @ Cart Service #}
     */
    function cartService($http, jasper, jsBar, $httpParamSerializer, $rootScope)
    {
        var service = this;

        service = {
            data          : {},
            getCart       : getCart,
            addToCart     : addToCart,
            changeItem    : changeItem,
            updateCartNote: updateCartNote
        };

        function getCart(callback)
        {
            $http({
                method : 'GET',
                url    : '/cart.js',
                headers: {
                    "Pragma"       : "no-cache",
                    "Expires"      : -1,
                    "Cache-Control": "no-cache"
                }
            }).then(function successCallback(response) {
                service.data = response.data;
                $rootScope.cartItemCount = service.data.item_count;

                // Run callback
                if ( callback && angular.isFunction(callback) )
                {
                    callback();
                }
            });
        }

        function addToCart(data, product, callback)
        {
            var template;

            if ( product.featured_image )
            {
                template = '<div class="row flex-items-middle">\n    <div class="col-2">\n        <img class="img-fluid" src="' + product.featured_image + '">\n    </div>\n    <div class="col">\n        <div class="mb-1">{{ "cart.general.added_to_cart"| t }}</div>\n        <a href="/cart">{{ "cart.general.go_to_cart" | t }}</a>\n    </div>\n</div>\n';
            }
            else
            {
                template = '<div class="mb-1">{{ "cart.general.added_to_cart"| t }}</div>\n<a href="/cart">{{ "cart.general.go_to_cart" | t }}</a>';
            }

            $.ajax({
                url     : '/cart/add.js',
                dataType: 'json',
                type    : 'post',
                data    : data,
                success : function (lineItem) {
                    // Get header cart jasper-bar
                    var cartBar = jsBar.get('ajax-cart-bar-header');

                    if ( window.jasper.cart_add_to_cart_behavior === 'jasper-bar' && cartBar )
                    {
                        // Update cart data and toggle cart bar
                        getCart(function () {
                            cartBar.toggle();
                        });
                    }
                    else
                    {
                        // Update cart data and notify
                        getCart(function () {
                            jasper.notify(template, 6000);
                        });
                    }

                    if ( callback )
                    {
                        callback();
                    }
                },
                error   : function (XMLHttpRequest, textStatus) {
                    var data = eval('(' + XMLHttpRequest.responseText + ')');
                    var response = data.description;
                    jasper.notify(response, 6000);
                }
            });
        }

        function changeItem(line, quantity, callback)
        {
            var data = {
                quantity: quantity,
                line    : line
            };

            $http({
                method : 'POST',
                url    : '/cart/change.js',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                data   : $httpParamSerializer(data),
            })
                .then(function successCallback(response) {
                    service.data = response.data;
                    $rootScope.cartItemCount = service.data.item_count;

                    if ( callback )
                    {
                        callback();
                    }
                });
        }

        function updateCartNote(note, callback)
        {
            var data = {
                note: attributeToString(note)
            };

            $http({
                method : 'POST',
                url    : '/cart/update.js',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                data   : $httpParamSerializer(data)
            }).then(function successCallback(response) {
            });
        }

        function attributeToString(attribute)
        {
            if ( (typeof attribute) !== 'string' )
            {
                attribute += '';
                if ( attribute === 'undefined' )
                {
                    attribute = '';
                }
            }
            return jQuery.trim(attribute);
        }

        return service;
    }

    /**
     {# @ Jasper Ajax Cart #}
     */
    function jsAjaxCartDirective()
    {
        return {
            restrict    : 'EA',
            controllerAs: 'jc',
            link        : function (scope, element, attrs, ctrl) {
                ctrl.init();
                element.on('click', function (e) {
                    if ( !angular.element(e.target).hasClass('cart-close-button') )
                    {
                        e.stopPropagation();
                    }
                });
            },
            controller  : function ($scope, $element, $timeout, cartService) {
                var vm = this;

                vm.cart = cartService;
                vm.loading = false;

                vm.init = init;
                vm.changeQuantity = changeQuantity;
                vm.removeProduct = removeProduct;
                vm.resizeImage = resizeImage;

                // Update the cart note in case they don't click update/checkout
                vm.updateCartNote = cartService.updateCartNote;

                function init()
                {
                    vm.cart.getCart();
                }

                function removeProduct(item)
                {
                    var line = vm.cart.data.items.indexOf(item) + 1;
                    var quantity = 0;

                    vm.cart.changeItem(line, quantity);
                }

                function changeQuantity(event, item)
                {
                    angular.element(event.target).blur();

                    vm.loading = true;

                    var line = vm.cart.data.items.indexOf(item) + 1;
                    var quantity = item.quantity;

                    vm.cart.changeItem(line, quantity, function () {
                        vm.loading = false;

                        $timeout(function () {
                            if ( !$element.hasClass('ng-hide') )
                            {
                                $element.find('[item-id="' + item.id + '"]').find('.jasper-number-input input').focus();
                            }
                        }, 200)
                    });
                }

                function resizeImage(img, size)
                {
                    var imgUrl = Shopify.resizeImage(img, size);
                    var customRatio = window.jasper.enable_product_custom_aspect_ratio;

                    if ( customRatio )
                    {
                        imgUrl = imgUrl.replace('.jpg', '_crop_{{ settings.product_image_crop }}.jpg');
                    }

                    return imgUrl;
                }
            }
        };
    }

    Array.prototype.getByProp = function (value, prop) {
        return this.filter(function (x) {
            return x[prop] === value;
        })[0];
    };

    String.prototype.repeat = function (times) {
        var result = "";
        var pattern = this;
        while ( times > 0 )
        {
            if ( times & 1 )
                result += pattern;
            times >>= 1;
            pattern += pattern;
        }
        return result;
    };

    /**
     {# @ Jasper Basic Search #}
     */
    function jsBasicSearchDirective($document, $animate, $timeout)
    {
        return {
            restrict    : 'EA',
            scope       : {},
            controllerAs: 'jbs',
            controller  : function ($scope) {
                var vm = this;
                vm.toggle = toggle;
                vm.elButton;
                vm.elForm;
                vm.elInput;
                vm.isActive = false;
                var NG_HIDE_CLASS = 'ng-hide';
                var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';

                $timeout(function () {
                    init();
                });

                function init()
                {
                    close();
                }

                function toggle()
                {
                    if ( vm.isActive )
                    {
                        close();
                    }
                    else
                    {
                        open();
                    }
                }

                function open(callback)
                {
                    vm.isActive = true;
                    $document.on('click', outSideClick);
                    $document.on('keydown', escapeToClose);
                    //vm.elInput.on('blur', close);
                    toggleElements(true, function () {
                        vm.elInput.focus();
                    });

                }

                function close()
                {
                    vm.isActive = false;
                    $document.off('click', outSideClick);
                    $document.off('keydown', escapeToClose);
                    toggleElements(false);
                }

                function toggleElements(value, callback)
                {
                    $scope.$evalAsync(function () {
                        $animate[!value ? 'removeClass' : 'addClass'](vm.elButton, NG_HIDE_CLASS, {
                            tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                        });
                        $animate[value ? 'removeClass' : 'addClass'](vm.elForm, NG_HIDE_CLASS, {
                            tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                        }).then(function () {
                            if ( callback )
                            {
                                callback();
                            }
                        });
                    })
                }

                /**
                 * Click Outside Event Handler
                 * @param event
                 */
                function outSideClick(event)
                {
                    var isChild = vm.elForm.has(event.target).length > 0;
                    var isSelf = vm.elForm[0] === event.target;

                    var isInside = isChild || isSelf;

                    if ( !isInside )
                    {
                        close();
                    }
                }

                function escapeToClose(ev)
                {
                    if ( vm.isActive && ev.keyCode === 27 )
                    {
                        close();
                    }
                }

            }
        }
    }

    /**
     {# @ Jasper Basic Search Button #}
     */
    function jsBasicSearchButtonDirective()
    {
        return {
            require : '^^jsBasicSearch',
            restrict: 'EA',
            link    : function (scope, element, attrs, ctrl) {
                ctrl.elButton = element;
                element.on('click', function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    ctrl.toggle();
                });
            }
        }
    }

    /**
     {# @ Jasper Basic Search Form#}
     */
    function jsBasicSearchFormDirective()
    {
        return {
            require : '^jsBasicSearch',
            restrict: 'EA',
            link    : function (scope, element, attrs, ctrl) {
                ctrl.elForm = element;
                ctrl.elInput = element.find('input');
            }
        }
    }

    /**
     {# @ Jasper Quick Search #}
     */
    function jsQuickSearchDirective($document, $timeout)
    {
        return {
            restrict    : 'EA',
            template    : '<form ng-submit="vm.submit()"\n      id="{[{vm.options.formId}]}" class="js-quick-search {[{vm.options.formClass}]}"\n      ng-class="{\'js-quick-search-visible\': vm.isVisible}">\n\n    <input id="{[{vm.options.inputId}]}"\n           class="search-input"\n           ng-class="vm.options.inputClass"\n           type="text"\n           placeholder="{[{vm.options.inputPlaceholder}]}"\n           aria-label="{[{vm.options.inputPlaceholder}]}"\n           ng-model="vm.query"\n           ng-focus="vm.focus()"\n           ng-model-options="vm.options.queryOptions" autocomplete="off"/>\n\n    <div class="search-results dropdown-menu" ng-show="vm.isVisible">\n\n        <div class="searching text-light" ng-show="vm.searching" ng-bind="vm.options.textSearching"></div>\n\n        <div class="no-results text-light"\n             ng-show="!vm.searching && (!vm.results || vm.results.length == 0)"\n             ng-bind="vm.options.textNoResults"></div>\n\n        <div ng-show="!vm.searching && vm.results && vm.results.length > 0">\n\n            <div class="results">\n                <a class="dropdown-item flex-items-middle" ng-repeat="result in vm.results"\n                   ng-href="{[{result.url}]}"\n                   ng-class="{\'angucomplete-selected-row bg-primary\': $index == currentIndex}">\n\n                    <div class="image-wrapper">\n                        <img ng-if="result.thumbnail && result.thumbnail != \'\'" ng-src="{[{ result.thumbnail }]}"\n                             class="img-fluid"/>\n                        <div ng-if="!result.thumbnail || result.thumbnail == \'\'"\n                             class="default-image img-fluid"></div>\n                    </div>\n\n                    <div class="col text-wrapper">\n                        <div class="title text-truncate" ng-bind-html="result.title"></div>\n\n                        <div ng-if="result.type && result.type != \'\'"\n                             class="type h6 text-light" ng-bind-html="result.type"></div>\n                    </div>\n\n                </a>\n\n            </div>\n\n            <hr class="my-2">\n\n            <a ng-href="{[{vm.options.remoteUrl + vm.query}]}" class="show-all-results dropdown-item">{[{vm.options.textShowAll}]}\n                ({[{vm.resultsCount}]})</a>\n\n        </div>\n\n    </div>\n</form>\n',
            scope       : {
                'options'     : '=?',
                'focusTrigger': '=?'
            },
            controllerAs: 'vm',
            compile     : function (tElement) {
                return function postLink(scope, element, attrs, ctrl) {
                    ctrl.element = element;
                    ctrl.init();

                };
            },
            controller  : function ($scope, $http, $q) {
                var vm = this,
                    inputEl,
                    resultsEl,
                    showAllEl,
                    httpCanceller = null,
                    httpCallInProgress = false,
                    tabIndex = -1,
                    defaultOpts = {
                        remoteJsonUrl   : '/search?view=json&q=',
                        remoteUrl       : '/search?q=',
                        queryOptions    : {
                            debounce: 300
                        },
                        minLength       : 3,
                        formId          : '',
                        formClass       : '',
                        inputClass      : '',
                        inputId         : '',
                        inputPlaceholder: '{{ "general.search.placeholder" | t }}',
                        textSearching   : '{{ "general.search.searching" | t }}',
                        textNoResults   : '{{ "general.search.no_results" | t }}',
                        textShowAll     : '{{ "general.search.show_all" | t }}'
                    };

                vm.element;
                vm.isVisible = false;
                vm.query = '';
                vm.resultsLoading = false;
                vm.results = null;
                vm.searching = false;

                // Methods
                vm.init = init;
                vm.show = show;
                vm.hide = hide;
                vm.focus = focus;
                vm.submit = submit;

                vm.options = !$scope.options ? defaultOpts : angular.extend(defaultOpts, $scope.options);

                function init()
                {
                    inputEl = vm.element.find('.search-input')[0];
                    resultsEl = vm.element.find('.results')[0].children;
                    showAllEl = vm.element.find('.show-all-results')[0];
                }

                $scope.$watch('focusTrigger', function (newVal, oldVal) {
                    if ( angular.isDefined(newVal) && newVal == true )
                    {
                        $timeout(function () {
                            inputEl.focus();
                        }, 300);
                    }
                });

                $scope.$watch('vm.isVisible', function (newVal, oldVal) {
                    if ( newVal !== undefined && newVal !== oldVal )
                    {
                        if ( newVal )
                        {
                            attachEvents();
                        }
                        else
                        {
                            detachEvents();
                        }
                    }
                });

                function submit()
                {
                    var url = vm.options.remoteUrl + vm.query;
                    window.location = url;
                }

                function focus()
                {
                    if ( vm.query && vm.query == '' )
                    {
                        hide();
                    }

                    if ( !vm.isVisible && vm.query.length >= vm.options.minLength )
                    {
                        getRemoteResults(vm.query);
                    }
                }

                function show()
                {
                    $scope.$evalAsync(function () {
                        vm.isVisible = true;
                    });
                }

                function hide()
                {
                    $scope.$evalAsync(function () {
                        //vm.query = '';
                        vm.isVisible = false;
                        vm.results = [];
                        vm.resultsCount = null;
                    });
                }

                function resetQuery()
                {
                    $scope.$evalAsync(function () {
                        vm.query = '';
                    });
                }

                function attachEvents()
                {
                    $document.on('click', outSideClick);
                    $document.on('keydown', keyDownEv);
                }

                function detachEvents()
                {
                    $document.off('click', outSideClick);
                    $document.off('keydown', keyDownEv);
                }

                function outSideClick(ev)
                {
                    // ev.preventDefault();
                    var isChild = vm.element.has(ev.target).length > 0;
                    var isSelf = vm.element[0] === ev.target;
                    var isInside = isChild || isSelf;

                    if ( !isInside )
                    {
                        hide();
                        resetQuery();
                    }
                }

                function keyDownEv(ev)
                {
                    var keyCode = ev.keyCode,
                        upKey = 38,
                        downKey = 40,
                        escapeKey = 27;

                    switch ( keyCode )
                    {
                        // Up
                        case upKey:
                            ev.preventDefault();
                            updateTabIndex(-1);
                            break;

                        // Down
                        case downKey:
                            ev.preventDefault();
                            updateTabIndex(1);
                            break;
                        // Escape
                        case escapeKey:
                            ev.preventDefault();
                            hide();
                            resetQuery();
                            break;
                    }

                    function updateTabIndex(val)
                    {
                        var newTabIndex = tabIndex + val;

                        if ( newTabIndex > vm.results.length )
                        {
                            tabIndex = -1;
                        }
                        else if ( newTabIndex < -1 )
                        {
                            tabIndex = vm.results.length;
                        }
                        else
                        {
                            tabIndex = newTabIndex;
                        }

                        switch ( tabIndex )
                        {
                            case -1:
                                inputEl.focus();
                                break;
                            case vm.results.length:
                                showAllEl.focus();
                                break;
                            default:
                                resultsEl[tabIndex].focus();
                        }
                    }
                }

                $scope.$watch('vm.query', function (newVal, oldVal) {
                        if ( angular.isUndefined(newVal) || angular.equals(newVal, oldVal) || newVal.length < vm.options.minLength )
                        {
                            hide();
                            return;
                        }
                        getRemoteResults(newVal);
                    }
                );

                function getRemoteResults(str)
                {
                    $scope.$evalAsync(function () {
                        vm.searching = true;
                        show();
                    });

                    tabIndex = -1;

                    var params = {},
                        url = vm.options.remoteJsonUrl + encodeURIComponent(str);

                    params.withCredentials = true;

                    cancelHttpRequest();
                    httpCanceller = $q.defer();
                    params.timeout = httpCanceller.promise;
                    httpCallInProgress = true;

                    $http.get(url, params)
                        .then(httpSuccessCallback(str))
                        .catch(httpErrorCallback)
                        .finally(function () {
                            httpCallInProgress = false;
                        });
                }

                function httpSuccessCallback(str)
                {
                    return function (response, status, headers, config) {
                        var responseData;
                        var responseDataStr;
                        // normalize return obejct from promise
                        if ( !status && !headers && !config && response.data )
                        {
                            if ( typeof response.data == 'object' )
                            {
                                responseData = response.data;
                            }
                            else
                            {
                                responseDataStr = JSON.stringify(response.data);
                                responseDataStr = responseDataStr.replace('<!-- END template -->', '').replace('<!-- BEGIN template --><!-- search.json -->', '');
                                responseData = JSON.parse(responseDataStr);
                                if ( typeof responseData == 'string' )
                                {
                                    responseData = JSON.parse(responseData);
                                }
                            }
                        }

                        $scope.$evalAsync(function () {
                            vm.searching = false;
                            vm.results = responseData.results;
                            vm.resultsCount = responseData.resultsCount;
                        });
                    };
                }

                function httpErrorCallback(errorRes, status, headers, config)
                {
                    $scope.$evalAsync(function () {
                        vm.searching = httpCallInProgress;
                    });

                    // normalize return obejct from promise
                    if ( !status && !headers && !config )
                    {
                        status = errorRes.status;
                    }

                    // cancelled/aborted
                    if ( status === 0 || status === -1 )
                    {
                        return;
                    }

                    if ( console && console.error )
                    {
                        console.error('http error');
                    }
                }

                function cancelHttpRequest()
                {
                    if ( httpCanceller )
                    {
                        httpCanceller.resolve();
                    }
                }

            }
        }
    }

    /**
     {# @ Jasper Flickity Simplified Carousel Directive#}
     */
    function jsFlickitySimplifiedCarouselDirective(FlickityService)
    {
        return {
            require : '^bc-flickity',
            restrict: 'EA',
            priority: 3,
            link    : function (scope, element, attrs, ctrl) {
                element.on('staticClick.flickity', function (event, pointer, cellElement, cellIndex) {
                    if ( typeof cellIndex == 'number' )
                    {
                        event.preventDefault();
                        event.stopPropagation();
                        FlickityService.select(ctrl.bcFlickityId, cellIndex);
                    }
                });
            }
        }
    }

    /**
     {# @ Jasper Flickity Select Directive#}
     */
    function jsFlickitySelectDirective(FlickityService, $timeout, $rootScope)
    {
        return {
            require : '^bc-flickity',
            restrict: 'EA',
            priority: 4,
            link    : function (scope, element, attrs, ctrl) {

                var unWatchSelectedIndex = scope.$watch(function () {
                    return element.attr('js-flickity-select');
                }, watchSelectedIndex, true);

                function watchSelectedIndex(newVal, oldVal)
                {
                    if ( angular.isDefined(newVal) )
                    {
                        $timeout(function () {
                            FlickityService.select(ctrl.bcFlickityId, newVal);
                        });
                    }
                }

                scope.$on('$destroy', function () {
                    unWatchSelectedIndex();
                });
            }
        }
    }

    /**
     {# @ Jasper Revolution Helper Directive #}
     */
    function jsRevolutionSliderHelperDirective()
    {
        return {
            restrict: 'A',
            scope   : {
                jsRevolutionSliderHelper: '='
            },
            link    : function (scope, element) {
                var data = scope.jsRevolutionSliderHelper,
                    revApi;

                var revSliderConfig = {
                    sliderType      : data.block_size > 1 ? 'standard' : 'hero',
                    sliderLayout    : data.section_height,
                    dottedOverlay   : 'none',
                    delay           : parseInt(data.delay),
                    responsiveLevels: [1240, 1024, 778, 480],
                    visibilityLevels: [1240, 1024, 778, 480],
                    gridwidth       : [1240, 1024, 778, 480],
                    gridheight      : [600, 500, 400, 300],
                    lazyType        : 'none',

                    //
                    parallax: {
                        type  : 'mouse',
                        origo : 'slidercenter',
                        speed : 2000,
                        levels: [2, 3, 4, 5, 6, 7, 12, 16, 10, 50, 46, 47, 48, 49, 50, 55]
                    },

                    shadow    : 0,
                    spinner   : 'off',
                    autoHeight: 'off',

                    disableProgressBar    : 'on',
                    hideThumbsOnMobile    : 'off',
                    hideSliderAtLimit     : 0,
                    hideCaptionAtLimit    : 0,
                    hideAllCaptionAtLilmit: 0,
                    debugMode             : false,
                    fallbacks             : {
                        simplifyAll         : 'off',
                        disableFocusListener: false
                    }
                }

                if ( data.section_height === 'fullscreen' )
                {
                    // Fullscreen settings
                    revSliderConfig['fullScreenAutoWidth'] = "off";
                    revSliderConfig['fullScreenAlignForce'] = "off";
                    revSliderConfig['fullScreenOffsetContainer'] = "";
                    revSliderConfig['fullScreenOffset'] = "";
                }

                // Navigation
                if ( data.block_size > 0 )
                {
                    revSliderConfig['navigation'] = {
                        keyboardNavigation   : 'off',
                        keyboard_direction   : 'horizontal',
                        mouseScrollNavigation: 'off',
                        mouseScrollReverse   : 'default',
                        onHoverStop          : 'off',
                        touch                : {
                            touchenabled       : 'on',
                            touchOnDesktop     : 'off',
                            swipe_threshold    : 75,
                            swipe_min_touches  : 50,
                            swipe_direction    : 'horizontal',
                            drag_block_vertical: false
                        }
                    }

                    // Arrows
                    if ( data.arrows )
                    {
                        revSliderConfig['navigation']['arrows'] = {
                            style        : 'gyges',
                            enable       : true,
                            hide_onmobile: false,
                            hide_onleave : false,
                            hide_under   : 480,
                            tmp          : '',
                            left         : {
                                h_align : 'left',
                                v_align : 'center',
                                h_offset: 0,
                                v_offset: 0
                            },
                            right        : {
                                h_align : 'right',
                                v_align : 'center',
                                h_offset: 0,
                                v_offset: 0
                            }
                        };

                        revSliderConfig['navigation']['bullets'] = {
                            enable      : true,
                            hide_over   : 480,
                            style       : 'ares',
                            hide_onleave: true,
                            direction   : 'horizontal',
                            h_align     : 'center',
                            v_align     : 'bottom',
                            h_offset    : 0,
                            v_offset    : 30,
                            space       : 5,
                            tmp         : ''
                        }
                    }
                }

                // Looping and autoplay
                if ( !data.autoplay )
                {
                    revSliderConfig['stopLoop'] = 'on';
                    revSliderConfig['stopAfterLoops'] = 0;
                    revSliderConfig['stopAtSlide'] = 1;
                }

                // Initialize RevSlider
                revApi = element.show().revolution(revSliderConfig);

                // Cleanup
                scope.$on('$destroy', function () {
                    revApi.revkill();
                });
            }
        }
    }

    /**
     {# @ Jasper Flickity Helper Directive #}
     */
    function jsFlickitySliderHelperDirective($rootScope, $timeout, FlickityService)
    {
        return {
            require : '^bc-flickity',
            restrict: 'EA',
            priority: 3,
            link    : function (scope, element, attrs, ctrl) {
                var captionEl, captionAnimation;
                var homeSliderUpdateTimeout = true;
                var timestamp = Date.now();
                var id = 'slider-' + timestamp;
                var lastEl;
                var slider;
                var lastSelectedIndex = 0;

                element[0].id = id;

                $timeout(function () {
                    FlickityService.select(id).then(function (data) {
                        slider = data;
                        changeHeaderFgClass();
                        animateCaption();
                    });
                }, 0);

                scope.$on('wipYoutube:player-ready', function (event, playerVM) {
                    if ( playerVM.el.parent().hasClass('is-selected') )
                    {
                        animateCaption();
                    }
                });

                scope.$on('wipYoutube:mobile-fallback', function () {
                    animateCaption();
                });

                var watchSlideChanges = $rootScope.$on('Flickity:' + id + ':select', function (event, data) {
                    if ( lastSelectedIndex === data.instance.selectedIndex )
                    {
                        return;
                    }

                    lastSelectedIndex = data.instance.selectedIndex;

                    updateVideoState();
                    animateCaption();
                    changeHeaderFgClass();
                });

                $(document).on('shopify:section:load', watchSectionLoad);

                function watchSectionLoad()
                {
                    changeHeaderFgClass();
                }

                function changeHeaderFgClass()
                {

                    if ( angular.isUndefined(attrs.matchHeaderFg) )
                    {
                        return;
                    }

                    if ( element.offset().top != 0 )
                    {
                        return;
                    }

                    var selectedElement = angular.element(slider.instance.selectedElement);
                    var fgClass = selectedElement.attr('fg-class');
                    var headerBgClass;

                    if ( fgClass === 'dark-fg' )
                    {
                        headerBgClass = 'light-bg';
                    }
                    else if ( fgClass === 'light-fg' )
                    {
                        headerBgClass = 'dark-bg';
                    }

                    var headerTop = $('#site-header .header-top');
                    var headerMiddle = $('#site-header .header-middle');
                    var headerBottom = $('#site-header .header-bottom');

                    changeBgClass(headerTop);
                    changeBgClass(headerMiddle);
                    changeBgClass(headerBottom);

                    function changeBgClass(el)
                    {
                        if ( el.length > 0 )
                        {
                            el.removeClass('dark-bg light-bg').addClass(headerBgClass);
                        }
                    }

                }

                function revertHeaderFgClasses()
                {
                    var headerTop = $('#site-header .header-top');
                    var headerMiddle = $('#site-header .header-middle');
                    var headerBottom = $('#site-header .header-bottom');

                    revertBgClass(headerTop);
                    revertBgClass(headerMiddle);
                    revertBgClass(headerBottom);
                }

                function revertBgClass(el)
                {
                    if ( el.length > 0 )
                    {
                        el.removeClass('light-bg dark-bg').addClass(el.attr('data-fg-class'));
                    }
                }

                function animateCaption()
                {
                    if ( !slider )
                    {
                        return;
                    }
                    lastEl = slider.instance.selectedElement;
                    prepareAnimateCaption();
                    triggerCaptionAnimation();
                }

                function prepareAnimateCaption()
                {
                    if ( !slider )
                    {
                        return;
                    }
                    captionEl = angular.element(slider.instance.selectedElement).find('.slide-caption')[0];
                    if ( !captionEl )
                    {
                        return;
                    }
                    captionAnimation = captionEl.dataset.captionAnimation;
                    angular.element(captionEl)[0].style.visibility = 'hidden';
                }

                function triggerCaptionAnimation()
                {
                    if ( !captionEl )
                    {
                        return;
                    }

                    angular.element(captionEl).animateCss(captionAnimation);
                    angular.element(captionEl)[0].style.visibility = 'visible';
                }

                function updateVideoState()
                {
                    var currentVideoScope = angular.element(lastEl).find('iframe').scope();
                    var nextVideoScope = angular.element(slider.instance.selectedElement).find('iframe').scope();
                    if ( currentVideoScope && currentVideoScope.vm.playerIsReady )
                    {
                        currentVideoScope.vm.player.pauseVideo();
                    }
                    if ( nextVideoScope && nextVideoScope.vm.playerIsReady && nextVideoScope.vm.options.playerVars.autoplay === 1 )
                    {
                        nextVideoScope.vm.player.playVideo();
                    }
                }

                $(document).on('shopify:block:select', watchAdminSlideSelect);

                function watchAdminSlideSelect(event)
                {
                    $timeout(function () {
                        if ( $(event.target).parents('#' + id).length > 0 )
                        {
                            var index = $('.slide').index($(event.target));
                            FlickityService.select(id, index);
                        }
                    }, 0);
                };

                scope.$on('$destroy', function () {
                    watchSlideChanges();
                    revertHeaderFgClasses();
                    $(document).off('shopify:section:load', watchSectionLoad);
                    $(document).off('shopify:block:select', watchAdminSlideSelect);
                });
            }
        }
    }

    /**
     {# @ Jasper Flickity Carousel Fix Directive #}
     */
    function jsFlickityCarouselFixDirective($rootScope, $timeout, FlickityService, jasper)
    {
        return {
            require : '^bc-flickity',
            restrict: 'EA',
            priority: 4,
            link    : function (scope, element, attrs, ctrl) {

                $timeout(function () {
                    checkSizes();
                    $rootScope.$on('jasper::matchMediaChanged', function (ev, currentStep, isOrBelow, isOrAbove) {
                        checkSizes();
                    });
                }, 0);

                function checkSizes()
                {
                    jasper.debounce(function () {
                        // calculate total width of all cells
                        var cellsWidth = 0;

                        element.find('.carousel-item').each(function (i, cell) {
                            cellsWidth += $(cell).outerWidth();
                        });

                        var id = element.attr('bc-flickity-id'),
                            flickityInstances = FlickityService.instances,
                            flickityExists = false;

                        for ( var i = 0; i < flickityInstances.length; i++ )
                        {
                            if ( flickityInstances[i].id === id )
                            {
                                flickityExists = true;
                                break;
                            }
                        }

                        if ( cellsWidth <= element.innerWidth() && flickityExists )
                        {
                            $timeout(function () {
                                FlickityService.destroy(id).then(function (result) {
                                });
                            });
                            $('button[bc-flickity-id="' + id + '"]').hide();
                        }
                        else if ( cellsWidth > element.innerWidth() && !flickityExists )
                        {
                            FlickityService
                                .create(element[0], id, scope.$eval(attrs.bcFlickity))
                                .then(
                                    function (result) {
                                        $('button[bc-flickity-id="' + id + '"]').show();
                                    }
                                );
                        }
                    }, 300);
                }
            }
        }
    }

    /**
     {# @ Jasper Absolute Header Fix#}
     */
    function jsAbsoluteHeaderFixDirective()
    {
        return {
            restrict: 'EA',
            link    : function (scope, element, attrs, ctrl) {

                updateVisibleAreas();

                scope.$on('wipYoutube:player-ready', function () {
                    updateVisibleAreas();
                });

                scope.$on('wipYoutube:video-updated', function () {
                    updateVisibleAreas();
                });

                scope.$watch(function () {
                    return element.height();
                }, function (newVal, oldVal) {
                    if ( newVal !== oldVal )
                    {
                        updateVisibleAreas();
                    }
                });

                function updateVisibleAreas()
                {
                    var headerHeight = angular.element('#shopify-section-header').children().eq(0).height();
                    var visibleAreas = element.find('.slide-visible-area');
                    var sliderPrevNextButtons = element.find('.flickity-prev-next-button');
                    var sizedCloseButton = element.find('.sized-close-button');

                    if ( element[0].offsetTop !== 0 )
                    {
                        visibleAreas.css('top', '0px');
                        sliderPrevNextButtons.css('margin-top', '0px');
                        sizedCloseButton.css('top', '0px');
                    }
                    else
                    {
                        visibleAreas.css('top', headerHeight + 'px');
                        sliderPrevNextButtons.css('margin-top', headerHeight / 2 + 'px');
                        sizedCloseButton.css('top', headerHeight + 'px');
                    }
                }
            }
        }
    }

    /**
     {# @ Jasper Fill Height Directive#}
     */
    function jsFillHeightDirective($timeout, $window, jasper)
    {
        return {
            restrict: 'EA',
            link    : function (scope, element, attrs, ctrl) {
                var windowWidth = $window.innerWidth,
                    newWindowWidth;

                $timeout(function () {
                    updateHeight();
                }, 500);

                scope.$watch(function () {
                    return element[0].offsetTop;
                }, function (newVal, oldVal) {
                    if ( newVal !== oldVal )
                    {
                        updateHeight();
                    }
                });

                $(window).resize(onResize);

                function onResize()
                {
                    jasper.debounce(function () {
                        windowSizeWatcher();
                    }, 400);
                }

                function windowSizeWatcher()
                {
                    newWindowWidth = $window.innerWidth;

                    var isMobile = jasper.isMobile();

                    if ( isMobile && newWindowWidth !== windowWidth )
                    {
                        updateHeight();
                    }
                    else if ( !isMobile )
                    {
                        updateHeight();
                    }
                }

                function updateHeight()
                {
                    var windowHeight = $window.innerHeight;

                    var headerHeight = angular.element('#shopify-section-header').children().eq(0).height();

                    var elHeight = windowHeight;

                    windowWidth = newWindowWidth;

                    var indexOfSection = Array.prototype.indexOf.call(element[0].parentElement.parentElement.children, element[0].parentElement);

                    // Is absolute header active or there is no header: set section height to window height for the first section
                    // Set section heights to window height except first one and full screen banner
                    if ( !element.hasClass('section-full-screen-banner') && indexOfSection === 0 && element[0].offsetTop !== 0 )
                    {
                        elHeight = windowHeight - headerHeight;
                    }

                    // Slider needs height
                    if ( element.hasClass('section-home-slider') )
                    {
                        element.css('height', elHeight + 'px');
                    }

                    // Set the min-height
                    element.css('min-height', elHeight + 'px');
                }

                scope.$on('$destroy', function () {
                    $(window).off('resize', onResize);
                });
            }
        }
    }

    /**
     {# @ Jasper Sticky Header Directive #}
     */
    function jsStickyHeaderDirective($document, $window, jasper)
    {
        return {
            restrict  : 'EA',
            scope     : true,
            link      : function (scope, element, attrs, ctrl, transcludeFn) {
                ctrl.el = element;
                ctrl.init();
            },
            controller: function ($scope) {
                var vm = this;
                var body = $document.find('body').eq(0);
                var siteHeader;
                var wrapper;

                vm.init = init
                vm.el;
                vm.isOpen;
                vm.elHtml;

                function init()
                {
                    siteHeader = $document[0].getElementById('site-header');
                    wrapper = $document[0].getElementById('wrapper');

                    vm.isOpen = false;
                    vm.el.addClass('animate-slide-from-top');
                    vm.el.addClass('ng-hide');
                    vm.el.addClass('ready');

                    body.addClass('sticky-header-active');

                    watchScroll();
                }

                function watchScroll()
                {
                    angular.element($window).bind('scroll', function (e) {
                        if ( $(window).scrollTop() > angular.element(siteHeader).offset().top + siteHeader.clientHeight )
                        {
                            show();
                        }
                        else
                        {
                            hide();
                        }
                    });
                }

                function show()
                {
                    if ( vm.isOpen )
                    {
                        return;
                    }
                    vm.isOpen = true;
                    $scope.$evalAsync(function () {
                        jasper.animateNgHide(true, vm.el);
                    });
                }

                function hide()
                {
                    if ( !vm.isOpen )
                    {
                        return;
                    }
                    vm.isOpen = false;
                    $scope.$evalAsync(function () {
                        jasper.animateNgHide(false, vm.el);
                        //jasper.hideStickyPopovers();

                        $('.js-popover.is-open, js-popover.is-open, [js-popover].is-open').each(function () {
                            // Only run this if popover's are coming from sticky header
                            if ( !$(this).hasClass('from-sticky-header') )
                            {
                                return;
                            }

                            // Removal function needs to be duplicated like this.
                            // Some parts, like scroll handler event, needs evalAsync
                            // while others don't like evalAsync at all!
                            $(this).removeClass('is-open');

                            $scope.$evalAsync(function () {
                                $(this).removeClass('is-open');
                            });
                        });
                    });
                }
            }
        }
    }

    /**
     {# @ Jasper Aside #}
     */
    function jsAsideDirective($rootScope, $document, jasper, $animate, $compile, $timeout, FlickityService)
    {
        return {
            restrict    : 'EA',
            scope       : true,
            link        : function (scope, element, attrs, ctrl) {
                ctrl.asidePos = attrs.jsAside === '' ? 'left-aside' : attrs.jsAside;
                ctrl.asideOpen = scope.$eval(attrs.jsAsideOpen);

                ctrl.init();
            },
            controllerAs: 'ja',
            controller  : function ($scope) {
                var vm = this;

                var body = angular.element($document[0].body),
                    className = 'aside-show',
                    backdropEl = '<div class="aside-backdrop z-index-9999 animate-fade-in-out" js-aside-toggle></div>',
                    isMobile;

                vm.init = init;

                vm.hide = hide;
                vm.show = show;
                vm.test = 'test';
                vm.asidePos;
                vm.asideOpen;

                function init()
                {
                    $timeout(function () {
                        body.addClass('aside-active');
                    });

                    $rootScope.jsAsideOpened = vm.asideOpen ? vm.asideOpen : false;

                    $rootScope.$broadcast('jsAsideDirective::Initialized');

                }

                $rootScope.$on('jasper::matchMediaChanged', function (ev, currentStep) {
                    if ( currentStep == 'sm' || currentStep == 'xs' )
                    {
                        isMobile = true;
                        hide();
                    }
                    else
                    {
                        isMobile = false;
                        if ( $rootScope.jsAsideOpened )
                        {
                            show();
                        }
                        removeBackdrop();
                    }
                });

                var showListener = $rootScope.$on('jsAsideDirective::show', show);
                var hideListener = $rootScope.$on('jsAsideDirective::hide', hide);
                var toggleListener = $rootScope.$on('jsAsideDirective::toggle', toggle);

                function toggle()
                {
                    $rootScope.jsAsideOpened ? hide() : show();
                }

                function show()
                {
                    body.addClass(className);

                    $rootScope.jsAsideOpened = true;

                    toggleBackdrop();

                    // Trigger window resize
                    $timeout(function () {
                        // Normal window trigger
                        $(window).trigger('resize');
                    }, 500);

                    // Update Carousels
                    jasper.updateFlickityCarousels();

                }

                function hide()
                {
                    if ( !$rootScope.jsAsideOpened )
                    {
                        return;
                    }

                    body.removeClass(className);

                    $rootScope.jsAsideOpened = false;

                    toggleBackdrop();

                    // Trigger window resize
                    $timeout(function () {
                        // Flickity Carousel trigger resize
                        jasper.updateFlickityCarousels();

                        // Normal window trigger
                        $(window).trigger('resize');
                    }, 500);
                }

                function toggleBackdrop()
                {
                    if ( !isMobile )
                    {
                        return;
                    }

                    if ( !$rootScope.jsAsideOpened )
                    {
                        removeBackdrop();
                    }
                    else
                    {
                        addBackdrop();
                    }
                }

                function addBackdrop()
                {
                    vm.backdropEl = $compile(angular.element(backdropEl))($rootScope);
                    $scope.$evalAsync(function () {
                        $animate.enter(vm.backdropEl, body);
                    });
                }

                function removeBackdrop()
                {
                    if ( vm.backdropEl )
                    {
                        $scope.$evalAsync(function () {
                            $animate.leave(vm.backdropEl);
                        });
                    }
                }

                $scope.$on('$destroy', function () {
                    body.removeClass('aside-active');

                    $rootScope.$broadcast('jsAsideDirective::Destroyed');

                    // Detach rootScope listeners
                    showListener();
                    hideListener();
                    toggleListener();
                });

            }
        }
    }

    /**
     {# @ Jasper Aside Toggler#}
     */
    function jsAsideToggleDirective($rootScope)
    {
        return {
            restrict: 'EA',
            scope   : {
                jsAsideToggle: '=?'
            },
            link    : function (scope, element, attrs) {
                element[0].addEventListener('click', listener);

                function listener()
                {

                    if ( scope.jsAsideToggle )
                    {

                        if ( scope.jsAsideToggle == 'show' )
                        {
                            $rootScope.$broadcast('jsAsideDirective::show');
                        }

                        if ( scope.jsAsideToggle == 'hide' )
                        {
                            $rootScope.$broadcast('jsAsideDirective::hide');
                        }

                    }
                    else
                    {
                        $rootScope.$broadcast('jsAsideDirective::toggle');
                    }
                }

                scope.$on('$destroy', function () {
                    element[0].removeEventListener('click', listener);
                });

            }
        }
    }

    /**
     {# @ Jasper Parent Expand#}
     */
    function jsParentExpandDirective($timeout)
    {
        return {
            restrict: 'EA',
            link    : function (scope, element) {
                $(element).parents('[uib-collapse]').each(function () {
                    var elementScope = angular.element(this).scope();

                    $timeout(function () {
                        if ( elementScope.toggleOpen && $.isFunction(elementScope.toggleOpen) )
                        {
                            elementScope.toggleOpen();
                        }
                    })
                });
            }
        }
    }

    /**
     {# @ Jasper Instagram Directive#}
     */
    function jsInstagramFeedDirective(jasper, $timeout)
    {
        return {
            restrict    : 'EA',
            controllerAs: 'vm',
            template    : '<a class="{[{vm.options.itemClass}]} image-wrapper" href="{[{image.link}]}" target="_blank" ng-repeat="image in vm.images">\n<img class="img-fluid w-100" ng-src="{[{image.images[vm.options.resolution].url}]}" alt=" {[{image.caption}]}"/>\n</a>',
            scope       : {
                jsInstagramFeed: '=?'
            },
            link        : function (scope, element, attrs, ctrl) {
                ctrl.init(element);
            },
            controller  : function ($scope) {
                var token = '{{ settings.instagram_feed_access_token }}';

                var vm = this,
                    defaultOpts = {
                        token     : token,
                        userId    : token.split('.')[0],
                        clientId  : '{{ settings.instagram_feed_client_id }}',
                        sortBy    : 'none',
                        resolution: 'standard_resolution',
                        itemClass : 'p-0 col-md-4 col-sm-6 col-12'
                    };

                vm.images;
                vm.options = !$scope.jsInstagramFeed ? defaultOpts : angular.extend(defaultOpts, $scope.jsInstagramFeed);

                if ( vm.options.itemPerRow > 3 )
                {
                    vm.options.resolution = 'low_resolution';
                }
                else
                {
                    vm.options.resolution = 'standard_resolution';
                }

                vm.init = init;

                function init(element)
                {
                    var feed = new Instafeed({
                        get        : 'user',
                        userId     : vm.options.userId,
                        clientId   : vm.options.clientId,
                        limit      : vm.options.rows * vm.options.itemPerRow,
                        sortBy     : vm.options.sortBy,
                        resolution : vm.options.resolution,
                        accessToken: vm.options.token,
                        mock       : true,
                        success    : function (response) {
                            vm.images = response.data;
                            $timeout(function () {
                                angular.element(element).imagesLoaded(function () {
                                    jasper.scrollReveal.sync();
                                });
                            });
                        }
                    });
                    feed.run();
                }
            }
        }
    };

    /**
     {# @ jsImagesLoaded Directive #}
     */
    function jsImagesLoadedDirective()
    {
        return {
            restrict        : 'AC',
            scope           : {
                imagesLoaded       : '=?',
                imagesLoadedOptions: '=?',
                imagesLoadedEvents : '=?',
                imagesLoadedClass  : '=?',
                imagesLoadedWatch  : '=?',
                imagesLoadedAlways : '&?',
                imagesLoadedDone   : '&?',
                imagesLoadedFail   : '&?'
            },
            bindToController: true,
            controllerAs    : 'vm',
            controller      : function ($scope, $element, $attrs, $timeout) {
                var vm = this;

                var eventNames = ['always', 'done', 'fail'];
                var events = vm.imagesLoaded || vm.imagesLoadedEvents;
                var options = vm.imagesLoadedOptions || {};
                var className = vm.imagesLoadedClass || 'js-images-loaded';
                var classUsed = $element.hasClass(className);

                $element.addClass(className);

                var init = function () {
                    $scope.$emit('imagesLoaded:started', $element);

                    if ( classUsed )
                    {
                        $element.addClass(className);
                    }

                    var imgLoad = imagesLoaded($element[0], options, function () {
                        $scope.$emit('imagesLoaded:loaded', $element);

                        $element.removeClass(className);

                        $scope.$apply(function () {
                            $scope.$parent.$imagesLoaded = true;
                        });
                    });

                    eventNames.forEach(function (eventName) {
                        imgLoad.on(eventName, function () {
                            if ( events && typeof events[eventName] === 'function' )
                            {
                                events[eventName].apply(this, [this, $element]);
                            }

                            if ( typeof vm['imagesLoaded' + (eventName[0].toUpperCase() + eventName.slice(1))] === 'function' )
                            {
                                vm['imagesLoaded' + (eventName[0].toUpperCase() + eventName.slice(1))].apply(this, [this, $element]);
                            }
                        });
                    });
                };

                if ( vm.imagesLoadedWatch )
                {
                    $scope.$watch('vm.imagesLoadedWatch', function () {
                        init();
                    });
                }
                else
                {
                    $timeout(init);
                }
            }
        };
    }

    /**
     {# @ Jasper Popup Directive #}
     */
    function jsPopupDirective($rootScope, ngDialog, $cookies, $timeout, jasper)
    {
        return {
            restrict    : 'EA',
            scope       : {
                interval       : '=?',
                delay          : '=?',
                additionalClass: '=?'
            },
            controllerAs: 'jp',
            controller  : function ($scope) {
                var vm = this;

                vm.interval = $scope.interval || 30;
                vm.delay = $scope.delay || 0;
                vm.additionalClass = $scope.additionalClass || '';

                var customPopupDismiss = $cookies.get('customPopupDismiss');

                $(document).on('shopify:section:select', sectionSelect);

                function sectionSelect(event)
                {
                    var isPopupSection = event.originalEvent.detail.sectionId === 'popup';
                    if ( isPopupSection )
                    {
                        openPopup();
                    }
                }

                var dialogClosedWatcher = $rootScope.$on('ngDialog.closed', dialogClosed);

                function dialogClosed(e, $dialog)
                {
                    var isCustomPopup = $dialog.hasClass('custom-popup');

                    if ( isCustomPopup )
                    {
                        if ( vm.dismissCustomPopup )
                        {
                            $cookies.put('customPopupDismiss', true);
                        }
                        else
                        {
                            var expireDate = new Date();
                            expireDate.setTime(expireDate.getTime() + (vm.interval * 60 * 1000));

                            $cookies.put('customPopupDismiss', false, {
                                expires: expireDate
                            });

                        }
                    }
                }

                if ( !customPopupDismiss )
                {
                    $timeout(function () {
                        openPopup();
                    }, vm.delay);
                }

                function openPopup()
                {
                    ngDialog.closeAll();

                    $timeout(function () {
                        // Open custom popup
                        var customPopup = ngDialog.open(
                            {
                                template : 'custom-popup-dialog-template.html',
                                className: 'ngdialog-theme-default custom-popup ' + vm.additionalClass,
                                scope    : $scope,
                                trapFocus: false
                            });

                        $rootScope.$on('ngDialog.opened', function (e, $dialog) {
                            var id = $dialog.attr('id');
                            if ( id === customPopup.id )
                            {
                                jasper.updateSpr();
                            }
                        });

                    });
                }

                // Cleanup on destroy
                $scope.$on('$destroy', function () {
                    $(document).off('shopify:section:select', sectionSelect);
                    dialogClosedWatcher();
                });

            },
            link        : function ($scope, $element, $attrs) {

            }
        }
    }

    /**
     {# @ Jasper Iclude Directive #}
     */
    function jsIncludeDirective($templateCache, $timeout, $compile, $rootScope)
    {
        return {
            restrict: 'EA',
            link    : function (scope, element, attrs) {
                $timeout(function () {
                    include();
                });

                $rootScope.$on('jsTemplate:updated', function (ev, id) {
                    if ( id == attrs.jsInclude )
                    {
                        include();
                    }
                });

                function include()
                {
                    var content = angular.copy($templateCache.get(attrs.jsInclude));
                    var compiled = $compile(content)(scope)

                    element.html(compiled);
                }
            }
        }
    }

    /**
     {# @ Jasper Template Directive #}
     */
    function jsTemplateDirective($templateCache, $rootScope)
    {
        return {
            restrict: 'A',
            terminal: true,
            compile : function (element, attr) {
                if ( attr.type === 'text/js-template' )
                {
                    var templateUrl = attr.id,
                        text = element[0].text;

                    $templateCache.put(templateUrl, text);
                }

                $rootScope.$broadcast('jsTemplate:updated', attr.id);
            }
        }
    }

    /**
     {# @ Jasper scroll To Directive #}
     */
    function jsScrollToDirective($document, $rootScope)
    {
        return {
            restrict: 'A',
            link    : function (scope, element, attrs) {
                var body = angular.element($document[0].body);
                var isStickyHeaderActive = body.hasClass('sticky-header-active');
                var stickyFix = 0;

                if ( isStickyHeaderActive )
                {
                    stickyFix = 65;
                }

                element.on('click', function () {
                    var scrollEl = angular.element(attrs.jsScrollTo);

                    if ( scrollEl.length > 0 )
                    {
                        var scrollPos = scrollEl.offset().top - stickyFix;

                        $('html, body').animate({
                            scrollTop: scrollPos
                        }, 350);
                    }
                });
            }
        }
    }

    /**
     {# @ Jasper scroll To Section Service #}
     */
    function jsScrollToSectionService($rootScope, $window, jasper, $timeout, $document)
    {
        var sections = {},
            activeSection,
            newActiveSection,
            body = angular.element($document[0].body);

        $timeout(function () {
            setActiveSection();
        });

        angular.element($window).bind('scroll', setActiveSection);

        function setActiveSection()
        {
            if ( Object.keys(sections).length > 0 )
            {
                jasper.debounce(function () {
                    newActiveSection = getActiveSection();

                    if ( newActiveSection != activeSection )
                    {
                        activeSection = newActiveSection;
                        $rootScope.$broadcast('jsScrollToSection::changed', activeSection);
                    }
                }, 200);
            }
        }

        function getActiveSection()
        {
            var activeSectionId;

            angular.forEach(sections, function (section, sectionId) {
                var offsetTop = angular.element(section).offset().top;

                var isStickyHeaderActive = body.hasClass('sticky-header-active');
                var stickyFix = 0;

                if ( isStickyHeaderActive )
                {
                    stickyFix = 65;
                }

                if ( offsetTop - stickyFix <= $window.scrollY && $window.scrollY <= offsetTop + section.scrollHeight - stickyFix )
                {
                    activeSectionId = sectionId;
                }
            });

            return activeSectionId;
        }

        var service = {
            init    : function () {

            },
            register: function (sectionId, section) {
                sections[sectionId] = section;
            },
            scrollTo: function (sectionId) {
                var section = angular.element(sections[sectionId]);

                if ( section.length > 0 )
                {
                    $('html, body').animate({
                        scrollTop: angular.element(sections[sectionId]).offset().top - 64
                    }, 350);

                    window.history.pushState('sectionId', 'sectionId', '/#' + sectionId);
                }
            }
        }
        return service;
    }

    /**
     {# @ Jasper scroll To Section Directive #}
     */
    function jsScrollToSectionDirective(jsScrollToSection, $document, $rootScope)
    {
        return {
            restrict: 'A',
            link    : function (scope, element, attrs) {
                var href = attrs.href.replace(window.jasper.shop_url, '');

                if ( href.match('^#') )
                {
                    var sectionId = href.slice(1);

                    init();

                    $(document).on('shopify:section:load', function (response) {
                        init();
                    });

                    element.on('click', function (ev) {
                        ev.preventDefault();
                        jsScrollToSection.scrollTo(sectionId);
                    });

                    $rootScope.$on('jsScrollToSection::changed', function (ev, activeSectionId) {
                        if ( activeSectionId === sectionId )
                        {
                            element.addClass('active');
                        }
                        else
                        {
                            element.removeClass('active');
                        }
                    });
                }

                function init()
                {
                    var section = $document[0].getElementById(sectionId);

                    if ( !section )
                    {
                        return;
                    }

                    jsScrollToSection.register(sectionId, section);
                }
            }
        }
    }

    /**
     {# @ Jasper fullscreen banner button #}
     */
    function jsFullscreenBannerButtonDirective()
    {
        return {
            restrict: 'A',
            link    : function (scope, element, attrs) {
                element.on('click', function (ev) {
                    ev.preventDefault();
                    $('html, body').animate({
                        scrollTop: $('#content-wrapper').offset().top
                    }, 500);
                });

            }
        }
    }

    /**
     {# @ focusIf Directive #}
     */
    function focusIfDirective($timeout)
    {
        return {
            restrict: 'A',
            link    : function ($scope, $element, $attrs) {
                var dom = $element[0];

                if ( $attrs.focusIf )
                {
                    $scope.$watch($attrs.focusIf, focus);
                }
                else
                {
                    focus(true);
                }

                function focus(condition)
                {
                    if ( condition )
                    {
                        $timeout(function () {
                            dom.focus();
                        }, $scope.$eval($attrs.focusDelay) || 0);
                    }
                }
            }
        };
    }

    /**
     {# @ ng enter Directive #}
     */
    function ngEnterDirective()
    {
        return function (scope, element, attrs) {
            element.bind("keydown keypress", function (event) {
                if ( event.which === 13 )
                {
                    scope.$apply(function () {
                        scope.$eval(attrs.ngEnter);
                    });

                    event.preventDefault();
                }
            });
        };
    }

    /**
     {# @ Jasper popper.js Popover Directive #}
     */
    function jsPopoverDirective($document, $timeout, $rootScope, jasper, ngDialog)
    {
        return {
            restrict    : 'ACE',
            scope       : {
                jsPopoverOptions: '=?',
                isOpen          : '=?'
            },
            controller  : function ($scope) {
                var vm = this;

                // Data
                vm.defaultOptions = {
                    placement             : 'right-start',
                    popoverClasses        : '',
                    appendToBody          : false,
                    closeOnClick          : false,
                    disableAutoPositioning: false
                };
                vm.options = {};
                vm.canPopoverHide = true;
                vm.instance = undefined;

                vm.popoverEl = false;
                vm.triggerEl = false;
                vm.contentEl = false;
                vm.referenceEl = false;
                vm.megaMenuId = false;

                // Methods
                vm.setOptions = setOptions;
                vm.setupMegaMenuPopover = setupMegaMenuPopover;

                vm.initPopover = initPopover;
                vm.updatePopover = updatePopover;
                vm.destroyPopover = destroyPopover;
                vm.destroyCompletely = destroyCompletely;

                vm.openPopover = openPopover;
                vm.closePopover = closePopover;

                vm.registerPopover = registerPopover;
                vm.registerTrigger = registerTrigger;
                vm.registerContent = registerContent;
                vm.registerMegaMenuId = registerMegaMenuId;

                //////////

                /**
                 * Set the options
                 *
                 * @param options
                 */
                function setOptions(options)
                {
                    vm.options = angular.extend({}, vm.defaultOptions, options);

                    // Set the trigger based on the global
                    // settings.menu_trigger if it's not set
                    if ( !options.trigger )
                    {
                        vm.options.trigger = '{{ settings.menu_trigger }}';
                    }

                    // Set modifiers for better positioning
                    vm.options.modifiers = {
                        flip           : {
                            enabled: false
                        },
                        preventOverflow: {
                            padding          : 0,
                            boundariesElement: 'viewport'
                        },
                        hide           : {
                            enabled: true
                        }
                    };

                    // Set the disable auto positioning
                    if ( angular.isDefined(options.disableAutoPositioning) && options.disableAutoPositioning === true )
                    {
                        vm.options.modifiers.preventOverflow.enabled = false;
                        vm.options.modifiers.hide.enabled = false;
                    }
                }

                /**
                 * Setup mega menu popover
                 */
                function setupMegaMenuPopover()
                {
                    // If megamenu is from 'site-header' or from 'sticky-header' and if it needs to be centered,
                    // set the '#site-header'/'#sticky-header' as the reference element,
                    // also set the the placement to the bottom-start
                    var siteHeaderChild = vm.popoverEl.parents('#site-header').length > 0;
                    var stickySiteHeaderChild = vm.popoverEl.parents('#sticky-site-header').length > 0;

                    // Open/Close megamenus when a section selected/deselected
                    // Only for header megamenus
                    if ( siteHeaderChild )
                    {
                        $document.on('shopify:section:select', openMegaMenuPopover);
                        $document.on('shopify:section:deselect', closeMegaMenuPopover);
                    }

                    function openMegaMenuPopover(response)
                    {
                        if ( response.detail.sectionId === vm.megaMenuId )
                        {
                            vm.openPopover();
                        }
                    }

                    function closeMegaMenuPopover(response)
                    {
                        if ( response.detail.sectionId === vm.megaMenuId )
                        {
                            vm.closePopover();
                        }
                    }

                    // Destroy and re-init the popover when related
                    // megamenu section changes
                    $document.on('shopify:section:unload', megaMenuSectionUnload);
                    $document.on('shopify:section:load', megaMenuSectionLoad);

                    function megaMenuSectionUnload(response)
                    {
                        if ( response.detail.sectionId === vm.megaMenuId )
                        {
                            vm.destroyPopover();
                        }
                    }

                    function megaMenuSectionLoad(response)
                    {
                        if ( response.detail.sectionId === vm.megaMenuId )
                        {
                            // After destroying the popover, Shopify will call this function and
                            // we will init the popover again. Before doing that, de-register all
                            // events because the popover will be re-initialized with these events..
                            $document.off('shopify:section:select', openMegaMenuPopover);
                            $document.off('shopify:section:deselect', closeMegaMenuPopover);
                            $document.off('shopify:section:unload', megaMenuSectionUnload);
                            $document.off('shopify:section:load', megaMenuSectionLoad);

                            // Init popover
                            vm.initPopover();
                        }
                    }

                    // If the megamenu is the child of the header or the sticky header, and content width is not custom
                    // change the reference element and the placement
                    if ( siteHeaderChild || stickySiteHeaderChild )
                    {
                        if ( window.jasper.megamenus[vm.megaMenuId].content_width !== 'custom' )
                        {
                            var megaMenuEl = angular.element('#shopify-section-' + vm.megaMenuId);

                            if ( megaMenuEl.length > 0 )
                            {
                                // Set the reference element
                                if ( siteHeaderChild )
                                {
                                    vm.referenceEl = angular.element('#site-header');
                                }
                                else if ( stickySiteHeaderChild )
                                {
                                    vm.referenceEl = angular.element('#sticky-site-header');
                                }

                                // Set the placement
                                vm.options.placement = 'bottom-center';
                            }
                        }
                        else
                        {
                            // Set the reference element to false so
                            // initPopover function can attach it again
                            vm.referenceEl = false;

                            // Set the placement
                            vm.options.placement = 'bottom-start';
                        }
                    }
                }

                /**
                 * Initialize the popover
                 */
                function initPopover()
                {
                    var touched;

                    // If we are dealing with a mega menu...
                    if ( vm.megaMenuId )
                    {
                        // Setup mega menu popovers
                        vm.setupMegaMenuPopover();
                    }

                    // Before initialize, set the reference element
                    var referenceEl = vm.referenceEl || vm.triggerEl;

                    // Initialize the popper
                    vm.instance = new Popper(referenceEl[0], vm.contentEl[0], vm.options);

                    // Click & Mouseenter logic
                    switch ( vm.options.trigger )
                    {
                        // Setup 'click' trigger event handlers
                        case 'click':

                            // trigger item click event
                            vm.triggerEl.on('click', function (event) {
                                event.preventDefault();

                                // Stop bubbling of the click event to prevent tooltip from
                                // closing if user clicks on the tooltip itself
                                event.stopPropagation();

                                triggerClickPopover(event);
                            });

                            break;

                        // Setup 'hover' trigger event handlers
                        case 'hover':

                            var eventListener;

                            if ( document.documentMode || /Edge/.test(navigator.userAgent) )
                            {
                                eventListener = 'pointerenter mouseenter';
                            }
                            else
                            {
                                eventListener = 'touchstart mouseenter';
                            }

                            vm.triggerEl.on(eventListener, function (event) {
                                // Stop propagation to stop other events
                                // from happening if the touchstart
                                // event happened
                                event.preventDefault();

                                if ( (event.originalEvent.pointerType && event.originalEvent.pointerType === 'touch') || (event.originalEvent.touches && event.originalEvent.touches.length > 0) )
                                {
                                    touched = true;

                                    // Stop click event and its propagation
                                    vm.triggerEl.on('click', function (event) {
                                        event.preventDefault();
                                        event.stopImmediatePropagation();
                                        event.stopPropagation();
                                    });

                                    event.stopImmediatePropagation();
                                    event.stopPropagation();

                                    triggerClickPopover(event);
                                }
                                else
                                {
                                    if ( !touched )
                                    {
                                        triggerHoverPopover(event);
                                    }

                                    touched = false;
                                }
                            });

                            break;

                        default:
                            break;
                    }

                    function triggerClickPopover()
                    {
                        // Broadcast event for other menus to close
                        $rootScope.$broadcast('jsPopover::menuAboutToOpen', vm.popoverEl);

                        $timeout(function () {
                            // Append the content to the body
                            appendPopoverToBody();

                            // Toggle the is-open class
                            vm.popoverEl.toggleClass('is-open');
                        });
                    }

                    function triggerHoverPopover()
                    {
                        // Register mouseleave
                        vm.triggerEl.on('mouseleave', triggerElMouseleave);

                        function triggerElMouseleave()
                        {
                            vm.canPopoverHide = true;

                            jasper.debounce(function () {
                                if ( !vm.canPopoverHide )
                                {
                                    return;
                                }

                                // De-register the content mouse events
                                vm.contentEl.off('mouseenter.contentEl');
                                vm.contentEl.off('mouseleave.contentEl');

                                // Remove the is-open class
                                vm.popoverEl.removeClass('is-open');

                            }, 175);

                            vm.triggerEl.off('mouseleave', triggerElMouseleave);
                        }

                        // mouseenter
                        vm.canPopoverHide = false;

                        if ( vm.popoverEl.hasClass('is-open') )
                        {
                            return;
                        }

                        // Register popover content mouse events
                        vm.contentEl.on('mouseenter.contentEl', function () {
                            vm.canPopoverHide = false;
                        });

                        vm.contentEl.on('mouseleave.contentEl', function () {
                            vm.canPopoverHide = true;

                            jasper.debounce(function () {
                                if ( !vm.canPopoverHide )
                                {
                                    return;
                                }

                                // Remove the is-open class
                                vm.popoverEl.removeClass('is-open');
                            }, 175);
                        });

                        // Broadcast event for other menus to close
                        $rootScope.$broadcast('jsPopover::menuAboutToOpen', vm.popoverEl);

                        // Add the is-open class
                        $timeout(function () {
                            vm.popoverEl.addClass('is-open');
                        });
                    }

                    // document click event
                    $document.on('touchstart click', function (event) {
                        // If it's set, stop bubbling of the click event
                        // to prevent popover from closing if user clicks
                        // on the popover content
                        if ( !vm.options.closeOnClick )
                        {
                            var popoverContentEl = angular.element(event.target).parents('js-popover-content');

                            if ( popoverContentEl.length > 0 && popoverContentEl[0] === vm.contentEl[0] )
                            {
                                event.stopPropagation();
                                return;
                            }
                        }

                        if ( vm.triggerEl.has(event.target).length > 0 || event.target === vm.triggerEl[0] )
                        {
                            event.stopPropagation();
                            return;
                        }

                        // Remove the is-open class
                        $timeout(function () {
                            vm.popoverEl.removeClass('is-open');
                        }, 300);
                    });

                    // Listen for shopify section load to update the popover positions
                    $document.on('shopify:section:load', function () {
                        if ( vm.instance )
                        {
                            vm.instance.update();
                        }
                    });

                    // Listen for new menu opening
                    $scope.$on('jsPopover::menuAboutToOpen', function (e, eventEl) {
                        // If element doesn't have the is-open class, bail...
                        if ( !vm.popoverEl.hasClass('is-open') )
                        {
                            return;
                        }

                        // If element equals to the event element, bail...
                        if ( vm.popoverEl === eventEl )
                        {
                            return;
                        }

                        // If content of this element has the event element, bail...
                        if ( vm.contentEl.find(eventEl).length > 0 )
                        {
                            return;
                        }

                        $timeout(function () {
                            // Remove the is-open class to close opened ones
                            vm.popoverEl.removeClass('is-open');
                        });
                    });

                    // Watch the is-open class to show/hide the tooltip programmatically
                    $scope.$watch(function () {
                            return vm.popoverEl.hasClass('is-open');
                        },
                        function (value) {
                            if ( angular.isUndefined(value) )
                            {
                                return;
                            }

                            if ( value )
                            {
                                $timeout(function () {
                                    // Append the content to the body
                                    appendPopoverToBody();

                                    // Show the popover content
                                    vm.contentEl.show();

                                    // Update the instance to fix the positioning
                                    vm.instance.update();
                                });
                            }
                            else
                            {
                                $timeout(function () {
                                    // Hide the popover content
                                    vm.contentEl.hide();

                                    // Append the content to its original location
                                    appendPopoverToOriginalLocation(vm.popoverEl);
                                });
                            }
                        }
                    );
                }

                /**
                 * Update the popover's position
                 */
                function updatePopover()
                {
                    vm.instance.update();
                }

                /**
                 * Destroy the popover
                 */
                function destroyPopover()
                {
                    vm.instance.destroy();
                }

                /**
                 * Destroy the popover completely
                 *
                 * This is required when scope destroyed,
                 * above one will only work when we regenerating
                 * the popover menu
                 */
                function destroyCompletely()
                {
                    vm.popoverEl.off();
                    vm.contentEl.off();
                    vm.triggerEl.off();

                    vm.popoverEl.remove();
                    vm.contentEl.remove();
                    vm.triggerEl.remove();

                    vm.destroyPopover();
                }

                /**
                 * Append popover to the body
                 */
                function appendPopoverToBody()
                {
                    // If appendToBody is not active, bail...
                    if ( !vm.options.appendToBody )
                    {
                        return;
                    }

                    // Get the body element
                    var body = angular.element('body');

                    // Append the popover to the body
                    vm.contentEl.appendTo(body);
                }

                /**
                 * Append popover content back to its original location
                 *
                 * @param originalEl
                 */
                function appendPopoverToOriginalLocation(originalEl)
                {
                    // If appendToBody is not active, bail...
                    if ( !vm.options.appendToBody )
                    {
                        return;
                    }

                    // Append the popover back to its original location
                    vm.contentEl.appendTo(originalEl);
                }

                /**
                 * Open the popover
                 */
                function openPopover()
                {
                    $timeout(function () {
                        vm.popoverEl.addClass('is-open');
                    });
                }

                /**
                 * Close the popover
                 */
                function closePopover()
                {
                    $timeout(function () {
                        vm.popoverEl.removeClass('is-open');
                    });
                }

                /**
                 * Register popover element
                 *
                 * @param element
                 */
                function registerPopover(element)
                {
                    vm.popoverEl = angular.element(element);
                }

                /**
                 * Register trigger element
                 *
                 * @param element
                 */
                function registerTrigger(element)
                {
                    vm.triggerEl = angular.element(element);
                }

                /**
                 * Register content element
                 *
                 * @param element
                 */
                function registerContent(element)
                {
                    vm.contentEl = angular.element(element);
                }

                /**
                 * Register mega menu id
                 *
                 * @param element
                 */
                function registerMegaMenuId(id)
                {
                    vm.megaMenuId = id;
                }
            },
            controllerAs: 'vm',
            link        : function (scope, element, attrs, PopoverController) {
                // Register the popover itself
                PopoverController.registerPopover(element);

                // Register the megamenu id if exists
                if ( attrs.megaMenuId )
                {
                    PopoverController.registerMegaMenuId(attrs.megaMenuId);
                }

                // Get the user options if exist and set them...
                scope.jsPopoverOptions = scope.jsPopoverOptions || {};
                PopoverController.setOptions(scope.jsPopoverOptions);

                // Attach the custom class that tells us the AutoPositioning is disabled
                if ( angular.isDefined(scope.jsPopoverOptions.disableAutoPositioning) && scope.jsPopoverOptions.disableAutoPositioning )
                {
                    PopoverController.popoverEl.addClass('auto-positioning-disabled');
                }

                // Attach the custom classes to the popover el
                PopoverController.popoverEl.addClass(scope.jsPopoverOptions.popoverClasses);

                // Attach the custom classes to the content el
                PopoverController.contentEl.addClass(scope.jsPopoverOptions.popoverClasses);

                // Init the popover
                PopoverController.initPopover();

                // Clean up on scope $destroy
                scope.$on('$destroy', function () {
                    PopoverController.destroyCompletely();
                });
            }
        }
    }

    function jsPopoverTriggerDirective()
    {
        return {
            restrict: 'AE',
            require : '^jsPopover',
            link    : function (scope, element, attrs, PopoverController) {
                // Register the popover trigger
                PopoverController.registerTrigger(element);
            }
        }
    }

    function jsPopoverContentDirective()
    {
        return {
            restrict: 'AE',
            require : '^jsPopover',
            link    : function (scope, element, attrs, PopoverController) {
                // Register the popover content
                PopoverController.registerContent(element);

                // Watch the x-out-of-boundaries attribute to show/hide the tooltip programmatically
                scope.$watch(function () {
                        return element[0].hasAttribute('x-out-of-boundaries');
                    },
                    function (current, old) {
                        if ( angular.isUndefined(current) && current === old )
                        {
                            return;
                        }

                        if ( current )
                        {
                            PopoverController.closePopover();
                        }
                    }
                );
            }
        }
    }

    /**
     {# @ Jasper SetWindowMegaMenuSettings #}
     */
    function jsSetWindowMegaMenuSettings()
    {
        return {
            restrict: 'AE',
            link    : function (scope, element, attrs) {
                var megaMenuId = attrs.id.replace(/'/g, '');
                var contentWidth = attrs.megaMenuContentWidth.replace(/'/g, '');
                var titleLink = attrs.megaMenuTitleLink.replace(/'/g, '');

                window.jasper.megamenus[megaMenuId].content_width = contentWidth;
                window.jasper.megamenus[megaMenuId].title_link = titleLink;
            }
        }
    }


    /**
     {# @ Jasper Sticky Directive #}
     */
    function jsStickyDirective($rootScope)
    {
        return {
            restrict: 'AE',
            link    : function (scope, element, attrs) {
                var stuck = false;

                // Get user defined config
                var config = {};

                if ( attrs.jsStickyOptions )
                {
                    config = scope.$eval(attrs.jsStickyOptions);
                }

                // Set the default config
                var defaults = {
                    offset_top: 32
                };

                // Check the sticky header...
                if ( $('body').hasClass('sticky-header-active') )
                {
                    defaults.offset_top = 96;
                }

                // Set the final options
                var options = angular.extend({}, defaults, config);

                // If mobile is not defined, activate the sticker for good...
                if ( angular.isUndefined(options.mobile) )
                {
                    // Activate the sticker
                    $('body').imagesLoaded(function () {
                        element.stick_in_parent(options);
                        stuck = true;
                    });
                }
                // Otherwise, we will watch the media steps and attach/detach the sticker...
                else
                {
                    $rootScope.$on('jasper::matchMediaChanged', function (ev, currentStep, isOrBelow) {
                        if ( isOrBelow(options.mobile) )
                        {
                            if ( stuck )
                            {
                                element.trigger("sticky_kit:detach");
                                stuck = false;
                            }
                        }
                        else
                        {
                            if ( !stuck )
                            {
                                $('body').imagesLoaded(function () {
                                    element.stick_in_parent(options);
                                    stuck = true;
                                });
                            }
                        }
                    });
                }
            }
        }
    }

    /**
     {# @ Jasper Filter Show More Directive #}
     */
    function jsFilterShowMoreDirective()
    {
        return {
            restrict: 'AE',
            scope   : false,
            link    : function (scope, element, attrs) {
                var maxHeight = attrs.jsFilterShowMore || 200;
                var showMoreButtonEl = $('<div class="show-more-button link"></div>');
                var elHeight;

                init();

                function init()
                {
                    elHeight = element.height();

                    showMoreButtonEl.text('{{ "products.general.show_all" | t }}');

                    element.append(showMoreButtonEl);

                    showMoreButtonEl.on('click', toggle);

                    function toggle()
                    {
                        var text = showMoreButtonEl.text();
                        showMoreButtonEl.text(text == '{{ "products.general.show_all" | t }}' ? '{{ "products.general.show_less" | t }}' : '{{ "products.general.show_all" | t }}');
                        element.toggleClass('show-all');
                    }

                    scope.$on('$destroy', function () {
                        showMoreButtonEl.off('click', toggle);
                        showMoreButtonEl.remove();
                    });
                }

                scope.$watch(function () {
                    return element.height();
                }, function (newVal, oldVal) {
                    elHeight = element.height();

                    if ( newVal !== undefined )
                    {
                        if ( elHeight < maxHeight )
                        {
                            element.removeClass('show-more-active');
                        }
                        else
                        {
                            element.addClass('show-more-active');
                        }
                    }
                });
            }
        }
    }

    /**
     {# @ Jasper Splash Screen Directive #}
     */
    function jsSplashScreenDirective($animate, $window, $timeout)
    {
        return {
            restrict: 'E',
            link    : function (scope, iElement) {

                $timeout(function () {
                    if ( iElement )
                    {
                        iElement.fadeOut(300, function () {
                            $(this).remove();
                            scope = iElement = null;
                        })
                    }
                })

            }
        }
    }

    function isAdBlockEnabled()
    {
        if ( window.adblockEnabled )
        {
            return true;
        }

        var test = document.getElementById('adBanner');

        var testDisplay = test && test.currentStyle ? test.currentStyle.display : getComputedStyle(test, null).display;

        if ( !test || testDisplay === 'none' )
        {
            window.adblockEnabled = true;
            return true;
        }
        else
        {
            window.adblockEnabled = false;
            return false;
        }
    }
})();